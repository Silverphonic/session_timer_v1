<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScoreSpotter v1 - Film Score Spotting App</title>
    <script src="https://cdn.jsdelivr.net/npm/xlsx-js-style@1.2.0/dist/xlsx.bundle.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600;700&family=IBM+Plex+Sans:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #1a1a1e;
            --bg-panel: #252529;
            --bg-input: #2d2d32;
            --bg-row-white: #2a2a2e;
            --bg-row-gray: #262628;
            --bg-active: #3a4a5a;
            --bg-active-static: #3a4a5a;
            --bg-error: #4a2a2a;
            --text-primary: #e8e8ec;
            --text-secondary: #a0a0a8;
            --text-dim: #707078;
            --accent-blue: #4a7ccc;
            --accent-green: #4a9c6c;
            --reel-blue: #3a5a8c;
            --reel-green: #3a7c5c;
            --border-color: #3a3a3e;
            --error-pink: #cc6a7a;
            --timer-glow: rgba(74, 124, 204, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'IBM Plex Sans', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        /* Header Metadata - Matching Spreadsheet Layout */
        .header-metadata {
            background: var(--bg-panel);
            padding: 16px 24px;
            border-bottom: 1px solid var(--border-color);
        }

        .header-top-row {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: start;
            margin-bottom: 12px;
        }

        .header-left {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .header-center {
            text-align: center;
        }

        .header-right {
            display: flex;
            flex-direction: column;
            gap: 4px;
            text-align: right;
        }

        .film-title-input {
            font-family: 'JetBrains Mono', monospace;
            font-size: 2.5rem;
            font-weight: 700;
            background: transparent;
            border: none;
            color: var(--text-primary);
            text-align: center;
            width: 100%;
            outline: none;
        }

        .film-title-input:focus {
            background: var(--bg-input);
            border-radius: 4px;
        }

        .header-field {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
        }

        .header-field.right {
            justify-content: flex-end;
        }

        .header-label {
            color: var(--text-dim);
            min-width: fit-content;
        }

        .header-input {
            background: transparent;
            border: none;
            border-bottom: 1px solid transparent;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.8rem;
            padding: 2px 4px;
            outline: none;
        }

        .header-input:hover {
            border-bottom-color: var(--border-color);
        }

        .header-input:focus {
            background: var(--bg-input);
            border-radius: 2px;
            border-bottom-color: var(--accent-blue);
        }

        .header-input.wide {
            width: 200px;
        }

        .header-input.medium {
            width: 150px;
        }

        .header-input.narrow {
            width: 100px;
        }

        .header-bottom-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-top: 8px;
            border-top: 1px solid var(--border-color);
        }

        .fps-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-secondary);
        }

        /* Main Layout */
        .main-container {
            display: flex;
            height: calc(100vh - 180px);
            min-height: 400px;
        }

        /* Video Panel - Floating Window */
        .video-panel {
            position: fixed;
            top: 200px;
            left: 20px;
            width: 480px;
            min-width: 320px;
            max-width: 900px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            z-index: 500;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            overflow: hidden;
        }

        .video-panel.collapsed {
            display: none;
        }

        .video-panel-header {
            padding: 10px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
            user-select: none;
            -webkit-user-select: none;
        }

        .video-panel-title {
            font-size: 0.8rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-dim);
        }

        .video-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 0;
            background: #000;
            min-height: 200px;
        }

        .video-player {
            width: 100%;
            max-height: 100%;
            background: #000;
            display: block;
        }

        .video-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 16px;
            color: var(--text-dim);
            text-align: center;
            padding: 40px;
        }

        .video-placeholder-icon {
            font-size: 3rem;
            opacity: 0.5;
        }

        .video-controls {
            padding: 12px 16px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .video-scrubber {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: var(--bg-input);
            border-radius: 4px;
            cursor: pointer;
        }

        .video-scrubber::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
        }

        .video-scrubber::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: var(--accent-blue);
            cursor: pointer;
            border: none;
        }

        .video-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .video-filename {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 200px;
        }

        .shuttle-indicator {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: var(--accent-blue);
            min-width: 50px;
            text-align: center;
        }

        .video-resize-handle {
            position: absolute;
            bottom: 0;
            right: 0;
            width: 20px;
            height: 20px;
            cursor: nwse-resize;
            background: transparent;
            z-index: 10;
        }

        .video-resize-handle::after {
            content: '';
            position: absolute;
            bottom: 4px;
            right: 4px;
            width: 10px;
            height: 10px;
            border-right: 2px solid var(--text-dim);
            border-bottom: 2px solid var(--text-dim);
            opacity: 0.5;
        }

        .video-resize-handle:hover::after {
            opacity: 1;
            border-color: var(--accent-blue);
        }

        .video-toggle-btn {
            position: fixed;
            left: 10px;
            top: 200px;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px 8px;
            cursor: pointer;
            color: var(--text-dim);
            font-size: 0.75rem;
            z-index: 100;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }

        .video-toggle-btn:hover {
            background: var(--bg-active);
            color: var(--text-primary);
        }

        /* Entry Table */
        .entry-section {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .table-header {
            display: grid;
            grid-template-columns: 12px 70px 120px 90px 200px 1fr 100px 24px;
            gap: 8px;
            padding: 12px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--text-dim);
            flex-shrink: 0;
        }

        .entries-container {
            flex: 1;
            overflow-y: auto;
            padding: 8px 0;
            padding-bottom: 300px;
            scroll-behavior: smooth;
        }

        .entry-row {
            display: grid;
            grid-template-columns: 12px 70px 120px 90px 200px 1fr 100px 24px;
            gap: 8px;
            padding: 10px 16px;
            align-items: center;
            transition: background 0.15s;
            cursor: pointer;
            border-bottom: 1px solid rgba(255,255,255,0.03);
            position: relative;
        }

        .entry-row:hover {
            background: var(--bg-active) !important;
        }

        .entry-row.selected {
            background: var(--bg-active-static) !important;
            outline: 2px solid var(--accent-blue);
            outline-offset: -2px;
        }

        .entry-row.pulsing {
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { background: var(--bg-active-static); }
            50% { background: rgba(74, 124, 204, 0.35); }
        }

        .entry-row.error {
            background: var(--bg-error) !important;
        }

        .row-delete-btn {
            opacity: 0;
            cursor: pointer;
            color: var(--text-dim);
            font-size: 0.75rem;
            padding: 4px 6px;
            border-radius: 3px;
            transition: all 0.15s;
            text-align: center;
        }

        .entry-row:hover .row-delete-btn {
            opacity: 0.5;
        }

        .row-delete-btn:hover {
            opacity: 1 !important;
            background: var(--bg-error);
            color: var(--text-primary);
        }

        .reel-bar {
            width: 8px;
            height: 100%;
            min-height: 36px;
            border-radius: 2px;
        }

        .reel-bar.blue { background: var(--reel-blue); }
        .reel-bar.green { background: var(--reel-green); }

        .cue-number {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--accent-blue);
        }

        .timecode-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            color: var(--text-primary);
            letter-spacing: 0.5px;
        }

        .timecode-edit-group {
            display: flex;
            align-items: center;
            gap: 2px;
        }

        .timecode-edit-field {
            width: 28px;
            background: var(--bg-input);
            border: 1px solid var(--accent-blue);
            border-radius: 3px;
            padding: 4px 2px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            text-align: center;
        }

        .timecode-edit-sep {
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
        }

        .action-badge {
            display: inline-block;
            padding: 5px 12px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .action-badge.cue-start { background: #2a4a3a; color: #6acc8a; }
        .action-badge.cue-end { background: #4a2a3a; color: #cc6a8a; }
        .action-badge.blank { background: transparent; color: transparent; min-width: 0; padding: 0; }
        .action-badge.shift { background: #3a3a4a; color: #8a8acc; }
        .action-badge.highlight { background: #4a4a2a; color: #cccc6a; }
        .action-badge.sting { background: #4a3a2a; color: #ccaa6a; }
        .action-badge.xfade { background: #3a2a4a; color: #aa6acc; }

        .tags-container {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .tag {
            background: var(--accent-blue);
            color: white;
            padding: 3px 8px 3px 10px;
            border-radius: 3px;
            font-size: 0.7rem;
            font-weight: 500;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }

        .tag-delete {
            cursor: pointer;
            opacity: 0.6;
            font-size: 0.65rem;
            padding: 0 2px;
            border-radius: 2px;
            line-height: 1;
        }

        .tag-delete:hover {
            opacity: 1;
            background: rgba(255,255,255,0.2);
        }

        .notes-cell {
            font-size: 0.875rem;
            color: var(--text-secondary);
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            min-height: 24px;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: text;
        }

        .notes-cell:hover {
            background: var(--bg-input);
        }

        .notes-input {
            width: 100%;
            background: var(--bg-input);
            border: 1px solid var(--accent-blue);
            border-radius: 3px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.875rem;
            padding: 4px 8px;
            outline: none;
        }

        .duration-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.85rem;
            color: var(--text-dim);
        }

        .duration-display.final {
            color: var(--text-primary);
            font-weight: 500;
        }

        /* Right Panel */
        .right-panel {
            width: 300px;
            background: var(--bg-panel);
            border-left: 1px solid var(--border-color);
            padding: 16px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 20px;
            flex-shrink: 0;
            max-height: 100%;
        }

        .panel-section {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .panel-section-title {
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--accent-blue);
            padding-bottom: 6px;
            margin-bottom: 4px;
            border-bottom: 1px solid var(--border-color);
        }

        .shortcut-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.8rem;
            padding: 3px 0;
        }

        .shortcut-key {
            font-family: 'JetBrains Mono', monospace;
            background: var(--bg-input);
            padding: 3px 8px;
            border-radius: 4px;
            font-size: 0.75rem;
            color: var(--accent-blue);
            border: 1px solid var(--border-color);
        }

        .shortcut-label {
            color: var(--text-secondary);
        }

        .theme-entry {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 4px 0;
        }

        .theme-delete-btn {
            width: 24px;
            height: 24px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-dim);
            cursor: pointer;
            font-size: 1rem;
            line-height: 1;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.15s;
        }

        .theme-delete-btn:hover {
            background: var(--bg-error);
            border-color: var(--error-pink);
            color: var(--error-pink);
        }

        .theme-usage-count {
            min-width: 22px;
            height: 22px;
            background: var(--bg-input);
            border-radius: 11px;
            font-size: 0.7rem;
            font-weight: 600;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'JetBrains Mono', monospace;
        }

        .theme-key-input {
            width: 40px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            text-align: center;
            text-transform: uppercase;
        }

        .theme-key-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .theme-meaning-input {
            flex: 1;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 6px 10px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.8rem;
        }

        .theme-meaning-input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Floating Timer */
        .floating-timer {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 16px 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            cursor: move;
            z-index: 1000;
            user-select: none;
            -webkit-user-select: none;
        }

        .floating-timer * {
            user-select: none;
            -webkit-user-select: none;
        }

        .floating-timer input,
        .floating-timer select {
            user-select: text;
            -webkit-user-select: text;
        }

        .floating-timer.playing {
            box-shadow: 0 8px 32px var(--timer-glow), 0 0 60px var(--timer-glow);
            border-color: var(--accent-blue);
        }

        .timer-display {
            font-family: 'JetBrains Mono', monospace;
            font-size: 4rem;
            font-weight: 700;
            text-align: center;
            letter-spacing: 3px;
            margin-bottom: 8px;
            user-select: none;
            -webkit-user-select: none;
        }

        .timer-display.playing {
            color: var(--accent-blue);
        }

        .timer-status {
            text-align: center;
            font-size: 0.75rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 1px;
            user-select: none;
            -webkit-user-select: none;
        }

        .timer-status.playing {
            color: var(--accent-blue);
        }

        .timer-settings-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px 24px;
            margin-top: 16px;
            padding-top: 16px;
            border-top: 1px solid var(--border-color);
            user-select: none;
            -webkit-user-select: none;
        }

        .timer-grid-cell {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .timer-settings {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 12px;
            padding-top: 12px;
            user-select: none;
            -webkit-user-select: none;
        }
            border-top: 1px solid var(--border-color);
        }

        .timer-setting-row {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.75rem;
        }

        .timer-setting-label {
            font-size: 0.7rem;
            color: var(--text-dim);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            font-weight: 500;
        }

        .timer-unit {
            font-size: 0.7rem;
            color: var(--text-dim);
            margin-left: 4px;
        }

        .timer-hint {
            font-size: 0.65rem;
            color: var(--text-dim);
            margin-left: 6px;
        }

        .timer-select {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 8px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.75rem;
        }

        .timer-select:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .timecode-input-group {
            display: flex;
            gap: 2px;
            align-items: center;
        }

        .timecode-field {
            width: 28px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 2px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-align: center;
        }

        .timecode-field:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        .timecode-separator {
            color: var(--text-dim);
            font-family: 'JetBrains Mono', monospace;
        }

        .reaction-time-field {
            width: 55px;
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 4px 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            text-align: center;
        }

        .reaction-time-field:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        /* Context Menu */
        .context-menu {
            position: fixed;
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            padding: 8px 0;
            z-index: 2000;
            min-width: 220px;
            display: none;
        }

        .context-menu.visible {
            display: block;
        }

        .context-menu-item {
            padding: 10px 16px;
            cursor: pointer;
            font-size: 0.85rem;
            color: var(--text-primary);
            transition: background 0.1s;
        }

        .context-menu-item:hover {
            background: var(--bg-active);
        }

        .context-menu-divider {
            height: 1px;
            background: var(--border-color);
            margin: 8px 0;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 3000;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .toast {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 20px;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease-out;
            font-size: 0.875rem;
        }

        .toast.error {
            border-color: var(--error-pink);
            color: var(--error-pink);
        }

        .toast.info {
            border-color: var(--accent-blue);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Save/Export Buttons */
        .save-export-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 300px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border-color);
            padding: 12px 24px;
            display: flex;
            gap: 12px;
            justify-content: space-between;
            align-items: center;
        }

        .save-export-buttons {
            display: flex;
            gap: 12px;
        }

        .copyright-notice {
            font-size: 0.7rem;
            color: var(--text-dim);
        }

        .copyright-notice a {
            color: var(--text-dim);
            text-decoration: none;
        }

        .copyright-notice a:hover {
            color: var(--text-primary);
            text-decoration: underline;
        }

        .btn {
            background: var(--bg-input);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 8px 16px;
            color: var(--text-primary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .btn:hover {
            background: var(--bg-active);
            border-color: var(--accent-blue);
        }

        .btn-primary {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .btn-primary:hover {
            background: #5a8cdc;
        }

        /* Empty State */
        .empty-state {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            color: var(--text-dim);
            font-size: 0.9rem;
            gap: 12px;
        }

        .empty-state-icon {
            font-size: 4rem;
            opacity: 0.3;
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 4000;
        }

        .modal-overlay.visible,
        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 24px;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 16px 64px rgba(0, 0, 0, 0.5);
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .modal-body {
            color: var(--text-secondary);
            margin-bottom: 24px;
            line-height: 1.5;
        }

        .modal-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: flex-end;
        }

        .btn-danger {
            background: #8a3a3a;
            border-color: #8a3a3a;
            color: white;
        }

        .btn-danger:hover {
            background: #aa4a4a;
            border-color: #aa4a4a;
        }

        .btn-secondary {
            background: #4a5a6a;
            border-color: #4a5a6a;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6a7a;
            border-color: #5a6a7a;
        }
    </style>
</head>
<body>
    <!-- Header Metadata - Matching Spreadsheet Layout -->
    <div class="header-metadata">
        <div class="header-top-row">
            <div class="header-left">
                <div class="header-field">
                    <span class="header-label">Director:</span>
                    <input type="text" class="header-input wide" id="director" placeholder="Name">
                </div>
                <div class="header-field">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="directorContact" placeholder="email / phone">
                </div>
                <div class="header-field" style="margin-top: 8px;">
                    <span class="header-label">Composer:</span>
                    <input type="text" class="header-input wide" id="composer" placeholder="Name">
                </div>
                <div class="header-field">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="composerContact" placeholder="email / phone">
                </div>
            </div>
            <div class="header-center">
                <input type="text" class="film-title-input" id="filmTitle" placeholder="FILM TITLE">
                <div class="header-field" style="justify-content: center; margin-top: 4px;">
                    <input type="text" class="header-input medium" id="version" placeholder="(version)" style="text-align: center;">
                </div>
                <div class="header-field" style="justify-content: center; margin-top: 4px;">
                    <span class="header-label">Picture Date:</span>
                    <input type="date" class="header-input narrow" id="pictureDate">
                </div>
            </div>
            <div class="header-right">
                <div class="header-field right">
                    <span class="header-label">Session Date:</span>
                    <input type="date" class="header-input narrow" id="sessionDate">
                </div>
                <div class="header-field right">
                    <span class="header-label">Producers:</span>
                    <input type="text" class="header-input wide" id="producers" placeholder="Names">
                </div>
                <div class="header-field right">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="producersContact" placeholder="email / phone">
                </div>
                <div class="header-field right" style="margin-top: 8px;">
                    <span class="header-label">Exec Prod:</span>
                    <input type="text" class="header-input wide" id="execProducers" placeholder="Names">
                </div>
                <div class="header-field right">
                    <span class="header-label">Contact:</span>
                    <input type="text" class="header-input wide" id="execProducersContact" placeholder="email / phone">
                </div>
            </div>
        </div>
        <div class="header-bottom-row">
            <div class="fps-display" id="fpsDisplay">FPS: 24</div>
        </div>
    </div>

    <!-- Floating Timer -->
    <div class="floating-timer" id="floatingTimer">
        <div class="timer-display" id="timerDisplay">01:00:00:00</div>
        <div class="timer-status" id="timerStatus">STOPPED</div>
        <div class="timer-settings-grid">
            <div class="timer-grid-cell">
                <span class="timer-setting-label">FPS</span>
                <select class="timer-select" id="fpsSelect">
                    <optgroup label="Film">
                        <option value="23.976">23.976 fps</option>
                        <option value="24" selected>24 fps</option>
                    </optgroup>
                    <optgroup label="PAL/European">
                        <option value="25">25 fps</option>
                    </optgroup>
                    <optgroup label="NTSC/North American">
                        <option value="29.97ndf">29.97 fps NDF</option>
                        <option value="29.97df">29.97 fps DF</option>
                        <option value="30">30 fps</option>
                    </optgroup>
                    <optgroup label="High Frame Rate">
                        <option value="48">48 fps</option>
                        <option value="50">50 fps</option>
                        <option value="59.94ndf">59.94 fps NDF</option>
                        <option value="59.94df">59.94 fps DF</option>
                        <option value="60">60 fps</option>
                    </optgroup>
                </select>
            </div>
            <div class="timer-grid-cell">
                <span class="timer-setting-label">Sync Timecode</span>
                <div class="timecode-input-group">
                    <input type="text" class="timecode-field" id="syncHH" value="" maxlength="2" placeholder="HH">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="syncMM" value="" maxlength="2" placeholder="MM">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="syncSS" value="" maxlength="2" placeholder="SS">
                    <span class="timecode-separator" id="syncFrameSep">:</span>
                    <input type="text" class="timecode-field" id="syncFF" value="" maxlength="2" placeholder="FF">
                    <button class="btn btn-primary" id="syncBtn" style="padding: 4px 8px; font-size: 0.7rem; margin-left: 4px;">SYNC</button>
                </div>
                <span class="timer-hint" style="font-size: 0.65rem; color: var(--text-dim);">Enter timecode at current frame, click SYNC</span>
            </div>
            <div class="timer-grid-cell">
                <span class="timer-setting-label">Jump</span>
                <div class="timecode-input-group">
                    <input type="text" class="timecode-field" id="jumpHH" value="" maxlength="2" placeholder="HH">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="jumpMM" value="" maxlength="2" placeholder="MM">
                    <span class="timecode-separator">:</span>
                    <input type="text" class="timecode-field" id="jumpSS" value="" maxlength="2" placeholder="SS">
                    <span class="timecode-separator" id="jumpFrameSep">:</span>
                    <input type="text" class="timecode-field" id="jumpFF" value="" maxlength="2" placeholder="FF">
                    <button class="btn" id="jumpBtn" style="padding: 4px 8px; font-size: 0.7rem; margin-left: 4px;">GO</button>
                </div>
            </div>
            <div class="timer-grid-cell">
                <span class="timer-setting-label">Reaction Buffer</span>
                <div class="timecode-input-group" style="align-items: center;">
                    <input type="number" class="reaction-time-field" id="reactionTime" value="2.0" step="0.1" min="0" max="10">
                    <span class="timer-unit">sec</span>
                    <span class="timer-hint">(press <strong>-</strong>)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Floating Video Window -->
    <div class="video-panel" id="videoPanel">
        <div class="video-panel-header" id="videoPanelHeader">
            <span class="video-panel-title" id="videoPanelTitle">Video Preview</span>
            <div style="display: flex; gap: 8px;">
                <button class="btn" id="loadVideoBtn" style="padding: 4px 10px; font-size: 0.7rem;">Load Video</button>
                <button class="btn" id="collapseVideoBtn" style="padding: 4px 8px; font-size: 0.7rem;">‚úï</button>
            </div>
            <input type="file" id="videoFileInput" accept="video/*" style="display: none;">
        </div>
        <div class="video-container" id="videoContainer">
            <div class="video-placeholder" id="videoPlaceholder">
                <div class="video-placeholder-icon">üé¨</div>
                <div>Click <strong>Load Video</strong> to open a video file</div>
                <div style="font-size: 0.75rem; opacity: 0.7;">Supports MP4, WebM, MOV</div>
                <div style="font-size: 0.7rem; opacity: 0.6; margin-top: 8px;">Your video stays on your computer ‚Äî nothing is uploaded.</div>
            </div>
            <video class="video-player" id="videoPlayer" style="display: none;"></video>
        </div>
        <div class="video-controls" id="videoControls" style="display: none;">
            <input type="range" class="video-scrubber" id="videoScrubber" min="0" max="1000" value="0">
            <div class="video-info">
                <span class="video-filename" id="videoFilename"></span>
                <span class="shuttle-indicator" id="shuttleIndicator"></span>
            </div>
        </div>
        <div class="video-resize-handle" id="videoResizeHandle"></div>
    </div>

    <!-- Video Toggle Button (shown when panel is collapsed) -->
    <button class="video-toggle-btn" id="videoToggleBtn" style="display: none;">‚ñ∂ Video</button>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Entry Section -->
        <div class="entry-section">
            <div class="table-header">
                <div></div>
                <div>Cue</div>
                <div>Timecode</div>
                <div>Action</div>
                <div>Tags</div>
                <div>Notes</div>
                <div>Duration</div>
                <div></div>
            </div>
            <div class="entries-container" id="entriesContainer">
                <div class="empty-state">
                    <div class="empty-state-icon">üé¨</div>
                    <div>Press <strong>‚Üí</strong> to start the timer</div>
                    <div>Press <strong>1-6</strong> or <strong>Esc</strong> to add cue markers</div>
                </div>
            </div>
        </div>

        <!-- Right Panel -->
        <div class="right-panel">
            <div class="panel-section">
                <div class="panel-section-title">Timer / Video Controls</div>
                <div class="shortcut-row">
                    <span class="shortcut-key">‚Üí</span>
                    <span class="shortcut-label">Play / Pause</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">‚áß + ‚Üê</span>
                    <span class="shortcut-label">Reset (when stopped)</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">,</span>
                    <span class="shortcut-label">Shuttle Reverse</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">.</span>
                    <span class="shortcut-label">Shuttle Forward</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">/</span>
                    <span class="shortcut-label">Shuttle Stop</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">&lt;</span>
                    <span class="shortcut-label">Frame Back</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">&gt;</span>
                    <span class="shortcut-label">Frame Forward</span>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-title">Action Keys</div>
                <div class="shortcut-row">
                    <span class="shortcut-key">1</span>
                    <span class="shortcut-label">Cue Start</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">2</span>
                    <span class="shortcut-label">(blank timestamp)</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">3</span>
                    <span class="shortcut-label">Shift</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">4</span>
                    <span class="shortcut-label">Highlight</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">5</span>
                    <span class="shortcut-label">Sting</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">6</span>
                    <span class="shortcut-label">Xfade</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Esc</span>
                    <span class="shortcut-label">Cue End</span>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-title">Other Controls</div>
                <div class="shortcut-row">
                    <span class="shortcut-key">-</span>
                    <span class="shortcut-label">Subtract Reaction Time</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">\</span>
                    <span class="shortcut-label">Next Reel</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Del</span>
                    <span class="shortcut-label">Remove Last Action</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Tab</span>
                    <span class="shortcut-label">Move Between Fields</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">Enter</span>
                    <span class="shortcut-label">Confirm Note</span>
                </div>
                <div class="shortcut-row">
                    <span class="shortcut-key">`</span>
                    <span class="shortcut-label">Deselect Entry</span>
                </div>
            </div>

            <div class="panel-section">
                <div class="panel-section-title">Thematic Tags</div>
                <div id="themeEntriesContainer">
                    <div class="theme-entry">
                        <input type="text" class="theme-key-input" maxlength="1" placeholder="Key">
                        <input type="text" class="theme-meaning-input" placeholder="Meaning">
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Save/Export Bar -->
    <div class="save-export-bar">
        <div class="copyright-notice">
            ¬©2025 Silverphonic SoundLab &nbsp;¬∑&nbsp; <a href="mailto:info@silverphonic.com">info@silverphonic.com</a> &nbsp;¬∑&nbsp; <a href="https://silverphonic.com" target="_blank">Silverphonic.com</a>
        </div>
        <div class="save-export-buttons">
            <button class="btn" id="helpBtn" style="margin-right: 16px;">Help</button>
            <button class="btn btn-danger" id="newSessionBtn">New Session</button>
            <button class="btn" id="downloadSessionBtn">Download Session</button>
            <button class="btn" id="loadSessionBtn">Load Session</button>
            <button class="btn" id="exportCsvBtn">Export CSV</button>
            <button class="btn btn-primary" id="exportXlsxBtn">Export Excel</button>
            <input type="file" id="loadSessionInput" accept=".json" style="display: none;">
        </div>
    </div>
    
    <!-- New Session Confirmation Modal -->
    <div class="modal-overlay" id="newSessionModal">
        <div class="modal">
            <div class="modal-title">Start New Session?</div>
            <div class="modal-body">
                This will clear all cue entries. Would you like to save your work first?
            </div>
            <div class="modal-buttons" style="flex-direction: column; gap: 8px;">
                <div style="display: flex; gap: 8px; justify-content: flex-end; width: 100%;">
                    <button class="btn" id="modalCancelBtn">Cancel</button>
                    <button class="btn" id="modalDownloadBtn">Download First</button>
                    <button class="btn" id="modalExportBtn">Export Excel First</button>
                </div>
                <div style="display: flex; gap: 8px; justify-content: flex-end; width: 100%; border-top: 1px solid var(--border-color); padding-top: 12px; margin-top: 4px;">
                    <button class="btn btn-secondary" id="modalKeepInfoBtn" title="Keep project info and thematic tags">New Session (Keep Project Info)</button>
                    <button class="btn btn-danger" id="modalClearBtn">New Session (Clear Everything)</button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Delete Entry Confirmation Modal -->
    <div class="modal-overlay" id="deleteEntryModal">
        <div class="modal">
            <div class="modal-title">Delete Entry?</div>
            <div class="modal-body" id="deleteEntryModalBody">
                Deleting this entry will break cue structure. Would you like to delete the entire cue?
            </div>
            <div class="modal-buttons">
                <button class="btn" id="deleteEntryCancelBtn">Cancel</button>
                <button class="btn btn-danger" id="deleteEntryConfirmBtn">Delete Entire Cue</button>
            </div>
        </div>
    </div>
    
    <!-- FPS Change Modal -->
    <div class="modal-overlay" id="fpsChangeModal">
        <div class="modal">
            <div class="modal-title">Frame Rate Change</div>
            <div class="modal-body">
                How would you like to convert existing timecodes?
                <div style="margin-top: 12px; font-size: 0.85rem; color: var(--text-dim);">
                    <strong>Preserve Frame Count:</strong> Keep the same number of frames. Timecodes will change to match the new frame rate.<br>
                    <em>Example: 2 sec @ 24fps (48 frames) ‚Üí 1.92 sec @ 25fps (48 frames)</em>
                </div>
                <div style="margin-top: 8px; font-size: 0.85rem; color: var(--text-dim);">
                    <strong>Preserve Time Position:</strong> Keep the same HH:MM:SS, adjust frames proportionally.<br>
                    <em>Example: 01:00:02:12 @ 24fps ‚Üí 01:00:02:12 @ 25fps (same wall-clock time)</em>
                </div>
            </div>
            <div class="modal-buttons">
                <button class="btn" id="fpsCancelBtn">Cancel</button>
                <button class="btn btn-primary" id="fpsPreserveFramesBtn">Preserve Frame Count</button>
                <button class="btn btn-primary" id="fpsPreserveTimeBtn">Preserve Time Position</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div class="modal-overlay" id="helpModal">
        <div class="modal" style="max-width: 700px; max-height: 85vh; overflow-y: auto;">
            <div class="modal-title">ScoreSpotter v1 - Quick Reference</div>
            <div class="modal-body" style="text-align: left; font-size: 0.85rem; line-height: 1.5;">
                
                <h3 style="margin-top: 0; color: var(--accent-blue);">Getting Started</h3>
                <ol style="margin: 8px 0; padding-left: 20px;">
                    <li>Enter your project information (Film Title, Director, Composer, etc.)</li>
                    <li>Load a video file (optional) - supports MP4, WebM, MOV</li>
                    <li>Set your frame rate to match your picture</li>
                    <li>Navigate to a frame with visible timecode and use <strong>Sync Timecode</strong> to match</li>
                    <li>Press <strong>‚Üí</strong> (Right Arrow) to start the timer</li>
                </ol>
                <p style="margin: 8px 0; font-size: 0.8rem; color: var(--text-dim); font-style: italic;">
                    Video files are loaded directly in your browser and never uploaded to any server. Your media stays completely local and private.
                </p>
                
                <h3 style="color: var(--accent-blue);">Playback Controls</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 8px 0;">
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>‚Üí</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Play / Pause</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>Shift + ‚Üê</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Reset to offset</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>,</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Shuttle reverse (1x ‚Üí 2x ‚Üí 4x ‚Üí 8x ‚Üí 16x)</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>.</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Shuttle forward (1x ‚Üí 2x ‚Üí 4x ‚Üí 8x ‚Üí 16x)</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>/</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Stop shuttle</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>&lt;</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Single frame back</td></tr>
                    <tr><td style="padding: 4px 8px;"><strong>&gt;</strong></td><td style="padding: 4px 8px;">Single frame forward</td></tr>
                </table>
                
                <h3 style="color: var(--accent-blue);">Marking Cues</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 8px 0;">
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color); width: 50px;"><strong>1</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color); width: 80px;">Cue Start</td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Begins a new music cue</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>2</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Blank</td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Timestamp marker (no label)</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>3</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Shift</td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Marks a shift/change within a cue</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>4</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Highlight</td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Marks a moment to highlight</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>5</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Sting</td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Marks a sting or stab</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>6</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Xfade</td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Crossfade - ends current cue, starts new one</td></tr>
                    <tr><td style="padding: 4px 8px;"><strong>Esc</strong></td><td style="padding: 4px 8px;">Cue End</td><td style="padding: 4px 8px;">Ends the current cue</td></tr>
                </table>
                
                <h3 style="color: var(--accent-blue);">Other Controls</h3>
                <table style="width: 100%; border-collapse: collapse; margin: 8px 0;">
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color); width: 100px;"><strong>A-Z</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Add thematic tag to selected entry</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>-</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Reaction buffer (subtract frames from current time)</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>`</strong> (backtick)</td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Deselect current entry</td></tr>
                    <tr><td style="padding: 4px 8px;"><strong>Ctrl/Cmd + Z</strong></td><td style="padding: 4px 8px;">Undo last action</td></tr>
                </table>
                
                <h3 style="color: var(--accent-blue);">Right-Click Menu</h3>
                <p style="margin: 8px 0;">Right-click any entry to access these options:</p>
                <table style="width: 100%; border-collapse: collapse; margin: 8px 0;">
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color); width: 220px;"><strong>Delete and Renumber</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Removes the entry and renumbers subsequent cues</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>Delete Without Renumbering</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Removes the entry, keeps cue numbers as-is</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>Insert Entry Before</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Adds a new entry one frame before this one</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>Insert Entry After</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Adds a new entry one frame after this one</td></tr>
                    <tr><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);"><strong>Set Reel Number (Renumber)</strong></td><td style="padding: 4px 8px; border-bottom: 1px solid var(--border-color);">Changes reel number for this and all following entries</td></tr>
                    <tr><td style="padding: 4px 8px;"><strong>Set Reel Number (Keep)</strong></td><td style="padding: 4px 8px;">Changes reel number for this entry only</td></tr>
                </table>
                
                <h3 style="color: var(--accent-blue);">Tips</h3>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li><strong>Click any entry</strong> to select it and jump to that timecode</li>
                    <li><strong>Click the timecode</strong> to edit it manually</li>
                    <li><strong>Click the notes field</strong> to add notes</li>
                    <li><strong>Click the ‚úï</strong> on the right side of any row to delete it</li>
                    <li><strong>Click the ‚úï</strong> on any tag to remove just that tag</li>
                    <li><strong>Thematic tags</strong> can be defined in the right panel (A-Z keys)</li>
                    <li><strong>Right-click entries</strong> for more options (delete, insert, renumber reels)</li>
                    <li>All work is <strong>auto-saved</strong> to your browser</li>
                    <li>Click the <strong>Help</strong> button in the bottom bar anytime to see these instructions</li>
                </ul>
                
                <h3 style="color: var(--accent-blue);">Cue Rules</h3>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li>Every cue must start with <strong>Cue Start</strong> or <strong>Xfade</strong></li>
                    <li>Every cue must end with <strong>Cue End</strong></li>
                    <li>If you try to add a mid-cue marker without an active cue, a Cue Start is auto-inserted</li>
                </ul>
                
                <h3 style="color: var(--accent-blue);">Exporting</h3>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li><strong>Download Session</strong>: Saves a JSON file you can reload later</li>
                    <li><strong>Export to Excel</strong>: Creates a styled spreadsheet for sharing</li>
                </ul>
                
            </div>
            <div class="modal-buttons">
                <button class="btn btn-primary" id="helpCloseBtn">Got it!</button>
            </div>
        </div>
    </div>

    <!-- Context Menu -->
    <div class="context-menu" id="contextMenu">
        <div class="context-menu-item" data-action="delete-renumber">Delete and Renumber</div>
        <div class="context-menu-item" data-action="delete-keep">Delete Without Renumbering</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="insert-before">Insert Entry Before</div>
        <div class="context-menu-item" data-action="insert-after">Insert Entry After</div>
        <div class="context-menu-divider"></div>
        <div class="context-menu-item" data-action="set-reel-renumber">Set Reel Number (Renumber Subsequent)</div>
        <div class="context-menu-item" data-action="set-reel-keep">Set Reel Number (Keep Subsequent)</div>
    </div>

    <!-- Toast Container -->
    <div class="toast-container" id="toastContainer"></div>

    <script>
        // ==================== STATE ====================
        const state = {
            entries: [],
            themes: {},
            metadata: {},
            timer: {
                isPlaying: false,
                currentFrames: 86400,  // Default to 01:00:00:00 at 24fps
                offsetFrames: 86400,   // Default offset 01:00:00:00 at 24fps
                fps: 24,
                isDropFrame: false,
                startTime: null,
                animationFrame: null
            },
            video: {
                loaded: false,
                duration: 0,
                filename: '',
                shuttleSpeed: 0,  // -4, -2, -1, 0, 1, 2, 4
                shuttleInterval: null,
                isManualSeeking: false  // Flag to prevent timeupdate from overwriting manual frame changes
            },
            currentReel: 1,
            currentCueInReel: 0,
            selectedEntryIndex: null,
            lastCueStartIndex: null,
            contextMenuEntryIndex: null,
            actionHistory: [],
            isEditingNotes: false,
            isEditingTimecode: false
        };

        // ==================== FRAME RATE HELPERS ====================
        function getFpsValue(fpsString) {
            const map = {
                '23.976': 23.976,
                '24': 24,
                '25': 25,
                '29.97ndf': 29.97,
                '29.97df': 29.97,
                '30': 30,
                '48': 48,
                '50': 50,
                '59.94ndf': 59.94,
                '59.94df': 59.94,
                '60': 60
            };
            return map[fpsString] || 24;
        }

        function isDropFrame(fpsString) {
            return fpsString.includes('df') && !fpsString.includes('ndf');
        }

        function getMaxFrames() {
            return Math.floor(state.timer.fps);
        }

        function roundToValidFrame(frame) {
            const maxFrame = getMaxFrames() - 1;
            if (frame < 0) {
                showToast(`Frame rounded to 0`, 'info');
                return 0;
            }
            if (frame > maxFrame) {
                showToast(`Frame ${frame} rounded to ${maxFrame}`, 'info');
                return maxFrame;
            }
            return Math.round(frame);
        }

        // ==================== TIMECODE CONVERSION ====================
        function framesToTimecode(totalFrames) {
            const fps = Math.round(state.timer.fps);
            const isDF = state.timer.isDropFrame;
            
            // Handle negative frames
            const isNegative = totalFrames < 0;
            let frames = Math.floor(Math.abs(totalFrames));
            
            if (isDF && (fps === 30 || fps === 60)) {
                const dropFrames = fps === 60 ? 4 : 2;
                const framesPerMin = fps * 60 - dropFrames;
                const framesPer10Min = fps * 60 * 10 - dropFrames * 9;
                
                const d = Math.floor(frames / framesPer10Min);
                const m = frames % framesPer10Min;
                
                if (m < dropFrames) {
                    frames = frames + dropFrames * d;
                } else {
                    frames = frames + dropFrames * d + dropFrames * Math.floor((m - dropFrames) / framesPerMin);
                }
            }
            
            const ff = frames % fps;
            const totalSeconds = Math.floor(frames / fps);
            const ss = totalSeconds % 60;
            const totalMinutes = Math.floor(totalSeconds / 60);
            const mm = totalMinutes % 60;
            const hh = Math.floor(totalMinutes / 60);
            
            const sep = isDF ? ';' : ':';
            const sign = isNegative ? '-' : '';
            
            return {
                display: `${sign}${String(hh).padStart(2, '0')}:${String(mm).padStart(2, '0')}:${String(ss).padStart(2, '0')}${sep}${String(Math.floor(ff)).padStart(2, '0')}`,
                hh, mm, ss, ff: Math.floor(ff), isNegative
            };
        }

        function timecodeToFrames(hh, mm, ss, ff) {
            const fps = Math.round(state.timer.fps);
            const isDF = state.timer.isDropFrame;
            
            let totalFrames = hh * 3600 * fps + mm * 60 * fps + ss * fps + ff;
            
            if (isDF && (fps === 30 || fps === 60)) {
                const dropFrames = fps === 60 ? 4 : 2;
                const totalMinutes = hh * 60 + mm;
                const droppedFrames = dropFrames * (totalMinutes - Math.floor(totalMinutes / 10));
                totalFrames -= droppedFrames;
            }
            
            return totalFrames;  // Allow negative values now
        }

        // ==================== TIMER ====================
        function updateTimerDisplay() {
            const tc = framesToTimecode(state.timer.currentFrames);
            document.getElementById('timerDisplay').textContent = tc.display;
        }

        function startTimer() {
            if (state.timer.isPlaying) return;
            
            // Stop any shuttle
            stopShuttle();
            
            state.timer.isPlaying = true;
            state.timer.startTime = performance.now() - (state.timer.currentFrames / state.timer.fps * 1000);
            
            document.getElementById('timerDisplay').classList.add('playing');
            document.getElementById('timerStatus').textContent = 'PLAYING';
            document.getElementById('timerStatus').classList.add('playing');
            document.getElementById('floatingTimer').classList.add('playing');
            
            // Start video if loaded
            const video = document.getElementById('videoPlayer');
            if (state.video.loaded && video) {
                video.play();
            }
            
            function tick() {
                if (!state.timer.isPlaying) return;
                
                // If video is loaded, sync timer to video
                if (state.video.loaded) {
                    const video = document.getElementById('videoPlayer');
                    const videoTimeSeconds = video.currentTime;
                    // Use Math.round for better frame accuracy
                    state.timer.currentFrames = state.timer.offsetFrames + Math.round(videoTimeSeconds * state.timer.fps);
                } else {
                    const elapsed = performance.now() - state.timer.startTime;
                    state.timer.currentFrames = Math.round(elapsed / 1000 * state.timer.fps);
                }
                updateTimerDisplay();
                updateVideoScrubber();
                
                state.timer.animationFrame = requestAnimationFrame(tick);
            }
            
            tick();
        }

        function stopTimer() {
            state.timer.isPlaying = false;
            
            if (state.timer.animationFrame) {
                cancelAnimationFrame(state.timer.animationFrame);
            }
            
            // Pause video if loaded
            const video = document.getElementById('videoPlayer');
            if (state.video.loaded && video) {
                video.pause();
            }
            
            document.getElementById('timerDisplay').classList.remove('playing');
            document.getElementById('timerStatus').textContent = 'STOPPED';
            document.getElementById('timerStatus').classList.remove('playing');
            document.getElementById('floatingTimer').classList.remove('playing');
        }

        function toggleTimer() {
            if (state.timer.isPlaying) {
                stopTimer();
            } else {
                startTimer();
            }
        }

        function resetTimer() {
            if (state.timer.isPlaying) return;
            
            stopShuttle();
            
            // Reset timer to offset position
            state.timer.currentFrames = state.timer.offsetFrames;
            updateTimerDisplay();
            
            // Reset video to start
            if (state.video.loaded) {
                const video = document.getElementById('videoPlayer');
                video.currentTime = 0;
                updateVideoScrubber();
            }
            
            showToast('Timer reset to offset', 'info');
        }
        
        function syncTimecode() {
            // Get the timecode the user says the current frame should be
            const hh = parseInt(document.getElementById('syncHH').value) || 0;
            const mm = parseInt(document.getElementById('syncMM').value) || 0;
            const ss = parseInt(document.getElementById('syncSS').value) || 0;
            const ff = roundToValidFrame(parseInt(document.getElementById('syncFF').value) || 0);
            
            if (hh === 0 && mm === 0 && ss === 0 && ff === 0) {
                showToast('Enter the timecode for the current frame', 'error');
                return;
            }
            
            // Calculate what the user says this frame should be (in frames)
            const targetFrames = timecodeToFrames(hh, mm, ss, ff);
            
            // Get current video position in frames (0 if no video)
            let currentVideoFrames = 0;
            if (state.video.loaded) {
                const video = document.getElementById('videoPlayer');
                currentVideoFrames = Math.round(video.currentTime * state.timer.fps);
            }
            
            // Calculate offset: offset = target - currentVideoPosition
            // So when video is at currentVideoPosition, timer shows targetFrames
            state.timer.offsetFrames = targetFrames - currentVideoFrames;
            
            // Update current frames to match
            state.timer.currentFrames = targetFrames;
            updateTimerDisplay();
            
            const tc = framesToTimecode(state.timer.offsetFrames);
            showToast(`Synced! Offset set to ${tc.display}`, 'info');
            
            // Clear the sync fields
            document.getElementById('syncHH').value = '';
            document.getElementById('syncMM').value = '';
            document.getElementById('syncSS').value = '';
            document.getElementById('syncFF').value = '';
            
            autoSave();
        }

        function jumpToTime() {
            const hh = parseInt(document.getElementById('jumpHH').value) || 0;
            const mm = parseInt(document.getElementById('jumpMM').value) || 0;
            const ss = parseInt(document.getElementById('jumpSS').value) || 0;
            const ff = roundToValidFrame(parseInt(document.getElementById('jumpFF').value) || 0);
            
            const wasPlaying = state.timer.isPlaying;
            if (wasPlaying) stopTimer();
            
            state.timer.currentFrames = timecodeToFrames(hh, mm, ss, ff);
            updateTimerDisplay();
            
            // Sync video to new time
            syncVideoToTimer();
            
            if (wasPlaying) startTimer();
            
            showToast(`Jumped to ${framesToTimecode(state.timer.currentFrames).display}`, 'info');
        }

        // ==================== VIDEO FUNCTIONS ====================
        function loadVideo(file) {
            const video = document.getElementById('videoPlayer');
            const placeholder = document.getElementById('videoPlaceholder');
            const controls = document.getElementById('videoControls');
            
            const url = URL.createObjectURL(file);
            video.src = url;
            
            video.onloadedmetadata = () => {
                state.video.loaded = true;
                state.video.duration = video.duration;
                state.video.filename = file.name;
                
                placeholder.style.display = 'none';
                video.style.display = 'block';
                controls.style.display = 'flex';
                
                document.getElementById('videoFilename').textContent = file.name;
                document.getElementById('videoScrubber').max = Math.floor(video.duration * 1000);
                
                // Reset timer to offset and sync video
                resetTimer();
                
                showToast(`Video loaded: ${file.name}`, 'info');
            };
            
            video.onerror = () => {
                showToast('Error loading video - format may not be supported', 'error');
            };
        }
        
        function syncVideoToTimer() {
            if (!state.video.loaded) return;
            
            const video = document.getElementById('videoPlayer');
            // Calculate video time from timer frames (accounting for offset)
            const videoFrames = state.timer.currentFrames - state.timer.offsetFrames;
            const videoTime = videoFrames / state.timer.fps;
            
            // Clamp to video duration
            video.currentTime = Math.max(0, Math.min(videoTime, state.video.duration));
            updateVideoScrubber();
        }
        
        function syncTimerToVideo() {
            if (!state.video.loaded) return;
            
            const video = document.getElementById('videoPlayer');
            const videoTimeSeconds = video.currentTime;
            // Use Math.round for better accuracy - video.currentTime has limited precision
            state.timer.currentFrames = state.timer.offsetFrames + Math.round(videoTimeSeconds * state.timer.fps);
            updateTimerDisplay();
        }
        
        function updateVideoScrubber() {
            if (!state.video.loaded) return;
            
            const video = document.getElementById('videoPlayer');
            const scrubber = document.getElementById('videoScrubber');
            scrubber.value = Math.floor(video.currentTime * 1000);
        }
        
        function onScrubberChange(e) {
            if (!state.video.loaded) return;
            
            const video = document.getElementById('videoPlayer');
            const newTime = parseInt(e.target.value) / 1000;
            video.currentTime = newTime;
            syncTimerToVideo();
            
            // Deselect current entry when scrubbing
            if (state.selectedEntryIndex !== null) {
                state.selectedEntryIndex = null;
                renderEntries();
            }
        }
        
        // Shuttle controls: , . /
        function shuttle(direction) {
            // direction: -1 for reverse, 0 for stop, 1 for forward
            if (direction === 0) {
                stopShuttle();
                return;
            }
            
            // Stop normal playback
            if (state.timer.isPlaying) {
                stopTimer();
            }
            
            // Deselect current entry when shuttling
            if (state.selectedEntryIndex !== null) {
                state.selectedEntryIndex = null;
                renderEntries();
            }
            
            // Cycle through speeds: 1x, 2x, 4x, then back to 1x
            const speeds = [1, 2, 4, 8, 16];
            let currentSpeedIndex = speeds.indexOf(Math.abs(state.video.shuttleSpeed));
            
            if (Math.sign(state.video.shuttleSpeed) === direction && currentSpeedIndex >= 0) {
                // Same direction, increase speed
                currentSpeedIndex = (currentSpeedIndex + 1) % speeds.length;
            } else {
                // Different direction or stopped, start at 1x
                currentSpeedIndex = 0;
            }
            
            state.video.shuttleSpeed = direction * speeds[currentSpeedIndex];
            
            // Update indicator
            updateShuttleIndicator();
            
            // Clear existing interval
            if (state.video.shuttleInterval) {
                clearInterval(state.video.shuttleInterval);
            }
            
            // Start shuttle
            const framesPerTick = state.video.shuttleSpeed;
            state.video.shuttleInterval = setInterval(() => {
                state.timer.currentFrames += framesPerTick;
                
                // Sync video if loaded
                if (state.video.loaded) {
                    const video = document.getElementById('videoPlayer');
                    const videoFrames = state.timer.currentFrames - state.timer.offsetFrames;
                    const videoTime = videoFrames / state.timer.fps;
                    
                    if (videoTime < 0 || videoTime > state.video.duration) {
                        // Stop at boundaries
                        stopShuttle();
                        return;
                    }
                    
                    video.currentTime = videoTime;
                    updateVideoScrubber();
                }
                
                updateTimerDisplay();
            }, 1000 / state.timer.fps);
        }
        
        function stopShuttle() {
            if (state.video.shuttleInterval) {
                clearInterval(state.video.shuttleInterval);
                state.video.shuttleInterval = null;
            }
            state.video.shuttleSpeed = 0;
            updateShuttleIndicator();
        }
        
        function singleFrameStep(direction) {
            // Stop any playback or shuttle
            if (state.timer.isPlaying) {
                stopTimer();
            }
            stopShuttle();
            
            // Deselect current entry when stepping
            if (state.selectedEntryIndex !== null) {
                state.selectedEntryIndex = null;
                renderEntries();
            }
            
            // Set flag to prevent timeupdate from overwriting our change
            state.video.isManualSeeking = true;
            
            // Move by one frame
            state.timer.currentFrames += direction;
            updateTimerDisplay();
            
            // Sync video (but video may not have frame-accurate precision)
            if (state.video.loaded) {
                const video = document.getElementById('videoPlayer');
                const videoFrames = state.timer.currentFrames - state.timer.offsetFrames;
                const videoTime = videoFrames / state.timer.fps;
                video.currentTime = Math.max(0, Math.min(videoTime, state.video.duration));
                updateVideoScrubber();
            }
            
            // Clear the flag after a short delay
            setTimeout(() => {
                state.video.isManualSeeking = false;
            }, 100);
        }
        
        function updateShuttleIndicator() {
            const indicator = document.getElementById('shuttleIndicator');
            if (!indicator) return;
            
            if (state.video.shuttleSpeed === 0) {
                indicator.textContent = '';
            } else {
                const speed = Math.abs(state.video.shuttleSpeed);
                const dir = state.video.shuttleSpeed > 0 ? '‚ñ∂' : '‚óÄ';
                indicator.textContent = `${dir} ${speed}x`;
            }
        }
        
        function collapseVideoPanel() {
            const panel = document.getElementById('videoPanel');
            const toggleBtn = document.getElementById('videoToggleBtn');
            
            panel.classList.add('collapsed');
            toggleBtn.style.display = 'block';
        }
        
        function expandVideoPanel() {
            const panel = document.getElementById('videoPanel');
            const toggleBtn = document.getElementById('videoToggleBtn');
            
            panel.classList.remove('collapsed');
            toggleBtn.style.display = 'none';
        }
        
        function updateVideoPanelTitle() {
            const titleEl = document.getElementById('videoPanelTitle');
            const filmTitle = document.getElementById('filmTitle').value || 'Film Title';
            const version = document.getElementById('version').value;
            
            let title = filmTitle;
            if (version) {
                title += ' - ' + version;
            }
            titleEl.textContent = title;
        }

        // ==================== ENTRIES ====================
        function getActionName(actionKey) {
            const actions = {
                '1': 'Cue Start',
                '2': '',  // Blank timestamp - no text
                '3': 'Shift',
                '4': 'Highlight',
                '5': 'Sting',
                '6': 'Xfade',
                '0': 'Cue End'
            };
            return actions[actionKey] !== undefined ? actions[actionKey] : '';
        }

        function getActionClass(actionKey) {
            const classes = {
                '1': 'cue-start',
                '2': 'blank',
                '3': 'shift',
                '4': 'highlight',
                '5': 'sting',
                '6': 'xfade',
                '0': 'cue-end'
            };
            return classes[actionKey] || '';
        }

        function findLastCueStart(beforeIndex) {
            // Find the most recent Cue Start OR Xfade (both start cues)
            for (let i = beforeIndex - 1; i >= 0; i--) {
                if (state.entries[i].action === '1' || state.entries[i].action === '6') {
                    return i;
                }
            }
            return null;
        }

        function calculateDuration(entryIndex) {
            const entry = state.entries[entryIndex];
            // Cue Start and Xfade both show 00:00:00:00 (they're the start of a cue)
            if (entry.action === '1' || entry.action === '6') {
                return framesToTimecode(0).display;
            }
            
            const lastStart = findLastCueStart(entryIndex);
            if (lastStart === null) {
                return '--:--:--:--';
            }
            
            const durationFrames = entry.frames - state.entries[lastStart].frames;
            return framesToTimecode(Math.max(0, durationFrames)).display;
        }

        function getCueNumber(entryIndex) {
            const entry = state.entries[entryIndex];
            // Both Cue Start and Xfade get cue numbers (they both start cues)
            if (entry.action !== '1' && entry.action !== '6') return '';
            return `${entry.reel}m${entry.cueNum}`;
        }

        function getReelColor(reel) {
            // Build a map of unique reels in order of first appearance
            const seenReels = [];
            for (const entry of state.entries) {
                if (!seenReels.includes(entry.reel)) {
                    seenReels.push(entry.reel);
                }
            }
            const reelIndex = seenReels.indexOf(reel);
            return reelIndex % 2 === 0 ? 'blue' : 'green';
        }

        function getCueGroupIndex(entryIndex) {
            let group = 0;
            for (let i = 0; i <= entryIndex; i++) {
                // Both Cue Start and Xfade start new cue groups
                if (state.entries[i].action === '1' || state.entries[i].action === '6') {
                    group++;
                }
            }
            return group;
        }

        function addEntry(actionKey) {
            const currentFrames = state.timer.currentFrames;
            
            // Recalculate cue state based on where this entry will be inserted chronologically
            const cueIsActive = isCueActiveAtFrame(currentFrames);
            
            // === CUE END (0/Esc) - requires active cue ===
            if (actionKey === '0') {
                if (!cueIsActive) {
                    playErrorSound();
                    showToast('No active cue to end - press 1 for Cue Start first', 'error');
                    return;
                }
                // Just end the cue
                const entry = {
                    frames: currentFrames,
                    action: '0',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(entry);
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === XFADE (6) - requires active cue, auto-inserts Cue End before ===
            else if (actionKey === '6') {
                if (!cueIsActive) {
                    playErrorSound();
                    showToast('No active cue to crossfade from - press 1 for Cue Start first', 'error');
                    return;
                }
                // Insert Cue End one frame before
                const autoEndEntry = {
                    frames: Math.max(0, currentFrames - 1),
                    action: '0',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(autoEndEntry);
                showToast(`Previous cue ended at ${framesToTimecode(currentFrames - 1).display}`, 'info');
                
                // Now add Xfade which starts a new cue
                state.currentCueInReel++;
                const entry = {
                    frames: currentFrames,
                    action: '6',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: state.currentCueInReel
                };
                state.entries.push(entry);
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === CUE START (1) - if cue active, auto-inserts Cue End before ===
            else if (actionKey === '1') {
                if (cueIsActive) {
                    // Insert Cue End one frame before
                    const autoEndEntry = {
                        frames: Math.max(0, currentFrames - 1),
                        action: '0',
                        tags: [],
                        notes: '',
                        reel: state.currentReel,
                        cueNum: null
                    };
                    state.entries.push(autoEndEntry);
                    showToast(`Previous cue ended at ${framesToTimecode(currentFrames - 1).display}`, 'info');
                }
                // Start new cue
                state.currentCueInReel++;
                const entry = {
                    frames: currentFrames,
                    action: '1',
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: state.currentCueInReel
                };
                state.entries.push(entry);
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === SHIFT (3), HIGHLIGHT (4), or STING (5) - if no cue, auto-inserts Cue Start before ===
            else if (actionKey === '3' || actionKey === '4' || actionKey === '5') {
                if (!cueIsActive) {
                    // Insert Cue Start one frame before
                    state.currentCueInReel++;
                    const autoStartEntry = {
                        frames: Math.max(0, currentFrames - 1),
                        action: '1',
                        tags: [],
                        notes: '',
                        reel: state.currentReel,
                        cueNum: state.currentCueInReel
                    };
                    state.entries.push(autoStartEntry);
                    playErrorSound();
                    showToast(`No active cue - auto-started at ${framesToTimecode(currentFrames - 1).display}`, 'error');
                }
                // Now add the Shift, Highlight, or Sting
                const entry = {
                    frames: currentFrames,
                    action: actionKey,
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(entry);
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // === BLANK TIMESTAMP (2) - just a timestamp, no action text ===
            else if (actionKey === '2') {
                if (!cueIsActive) {
                    // Auto-insert Cue Start one frame before
                    state.currentCueInReel++;
                    const autoStartEntry = {
                        frames: Math.max(0, currentFrames - 1),
                        action: '1',
                        tags: [],
                        notes: '',
                        reel: state.currentReel,
                        cueNum: state.currentCueInReel
                    };
                    state.entries.push(autoStartEntry);
                    playErrorSound();
                    showToast(`No active cue - auto-started at ${framesToTimecode(currentFrames - 1).display}`, 'error');
                }
                const entry = {
                    frames: currentFrames,
                    action: '2', // Will display as blank
                    tags: [],
                    notes: '',
                    reel: state.currentReel,
                    cueNum: null
                };
                state.entries.push(entry);
                state.actionHistory.push({ type: 'entry', index: state.entries.length - 1 });
            }
            
            // Sort entries chronologically
            state.entries.sort((a, b) => a.frames - b.frames);
            
            // Recalculate cue state and find the new entry's index
            recalculateCueState();
            
            // Find the entry we just added (by frames and action)
            const addedEntry = state.entries.find(e => e.frames === currentFrames && e.action === actionKey);
            if (addedEntry) {
                state.selectedEntryIndex = state.entries.indexOf(addedEntry);
            } else {
                state.selectedEntryIndex = state.entries.length - 1;
            }
            
            renderEntries();
            scrollToEntry(state.selectedEntryIndex);
            autoSave();
        }
        
        // Check if a cue is active at a given frame position (based on chronological order)
        function isCueActiveAtFrame(targetFrames) {
            // Sort entries by frames to check chronologically
            const sortedEntries = [...state.entries].sort((a, b) => a.frames - b.frames);
            
            let cueActive = false;
            for (const entry of sortedEntries) {
                if (entry.frames > targetFrames) break;
                
                if (entry.action === '1' || entry.action === '6') {
                    cueActive = true;
                } else if (entry.action === '0') {
                    cueActive = false;
                }
            }
            return cueActive;
        }

        function addTagToEntry(key, entryIndex = null) {
            const index = entryIndex !== null ? entryIndex : state.selectedEntryIndex;
            if (index === null) return;
            
            const theme = state.themes[key.toLowerCase()];
            if (!theme) {
                showToast(`No theme defined for key "${key.toUpperCase()}"`, 'info');
                return;
            }
            
            const entry = state.entries[index];
            if (!entry.tags.includes(theme)) {
                entry.tags.push(theme);
                state.actionHistory.push({ type: 'tag', index: index, tag: theme });
                renderEntries();
                autoSave();
            }
        }

        function removeLastAction() {
            if (state.actionHistory.length === 0) return;
            
            const lastAction = state.actionHistory.pop();
            
            if (lastAction.type === 'entry') {
                const removed = state.entries.pop();
                // If we removed a Cue Start or Xfade, decrement the cue counter
                if (removed.action === '1' || removed.action === '6') {
                    state.currentCueInReel--;
                }
                // Recalculate the cue state from scratch
                recalculateCueState();
                state.selectedEntryIndex = state.entries.length > 0 ? state.entries.length - 1 : null;
            } else if (lastAction.type === 'tag') {
                const entry = state.entries[lastAction.index];
                const tagIndex = entry.tags.indexOf(lastAction.tag);
                if (tagIndex > -1) {
                    entry.tags.splice(tagIndex, 1);
                }
            } else if (lastAction.type === 'note') {
                const entry = state.entries[lastAction.index];
                entry.notes = lastAction.previousNote || '';
            }
            
            renderEntries();
            autoSave();
            showToast('Last action removed', 'info');
        }

        function nextReel() {
            state.currentReel++;
            state.currentCueInReel = 0;
            showToast(`Now on Reel ${state.currentReel}`, 'info');
        }

        // ==================== RENDERING ====================
        function renderEntries() {
            const container = document.getElementById('entriesContainer');
            
            if (state.entries.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üé¨</div>
                        <div>Press <strong>‚Üí</strong> to start the timer</div>
                        <div>Press <strong>1-6</strong> or <strong>Esc</strong> to add cue markers</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            
            state.entries.forEach((entry, index) => {
                const cueGroup = getCueGroupIndex(index);
                const bgColor = cueGroup % 2 === 0 ? 'var(--bg-row-gray)' : 'var(--bg-row-white)';
                const reelColor = getReelColor(entry.reel);
                const isSelected = index === state.selectedEntryIndex;
                const isPulsing = isSelected && state.timer.isPlaying;
                const tc = framesToTimecode(entry.frames);
                
                const isFinalDuration = entry.action === '0';  // Only Cue End is final, not Xfade
                
                html += `
                    <div class="entry-row ${isSelected ? (isPulsing ? 'pulsing' : 'selected') : ''}" 
                         data-index="${index}"
                         style="background: ${isSelected ? 'var(--bg-active-static)' : bgColor};">
                        <div class="reel-bar ${reelColor}"></div>
                        <div class="cue-number">${getCueNumber(index)}</div>
                        <div class="timecode-display" data-field="timecode">${tc.display}</div>
                        <div class="action-cell"><span class="action-badge ${getActionClass(entry.action)}">${getActionName(entry.action)}</span></div>
                        <div class="tags-container">
                            ${entry.tags.map((tag, tagIndex) => `<span class="tag" data-tag-index="${tagIndex}">${tag}<span class="tag-delete" data-entry="${index}" data-tag="${tagIndex}">‚úï</span></span>`).join('')}
                        </div>
                        <div class="notes-cell" data-field="notes">${entry.notes || '<span style="color: var(--text-dim); font-style: italic;">Click to add note...</span>'}</div>
                        <div class="duration-display ${isFinalDuration ? 'final' : ''}">${calculateDuration(index)}</div>
                        <div class="row-delete-btn" data-delete-row="${index}">‚úï</div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Add click handlers
            container.querySelectorAll('.entry-row').forEach(row => {
                row.addEventListener('click', (e) => {
                    const index = parseInt(row.dataset.index);
                    const field = e.target.closest('[data-field]');
                    
                    if (field && field.dataset.field === 'notes') {
                        e.stopPropagation();
                        makeNotesEditable(index);
                    } else if (field && field.dataset.field === 'timecode') {
                        e.stopPropagation();
                        state.selectedEntryIndex = index;
                        renderEntries();
                        makeTimecodeEditable(index);
                    } else {
                        state.selectedEntryIndex = index;
                        renderEntries();
                        
                        // Jump to timecode when stopped
                        if (!state.timer.isPlaying) {
                            const entry = state.entries[index];
                            state.timer.currentFrames = entry.frames;
                            updateTimerDisplay();
                            
                            // Set flag to prevent timeupdate from overwriting
                            state.video.isManualSeeking = true;
                            syncVideoToTimer();
                            setTimeout(() => {
                                state.video.isManualSeeking = false;
                            }, 100);
                        }
                    }
                });
                
                row.addEventListener('contextmenu', (e) => {
                    e.preventDefault();
                    state.contextMenuEntryIndex = parseInt(row.dataset.index);
                    showContextMenu(e.clientX, e.clientY);
                });
            });
            
            // Add tag delete handlers
            container.querySelectorAll('.tag-delete').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryIndex = parseInt(btn.dataset.entry);
                    const tagIndex = parseInt(btn.dataset.tag);
                    deleteTagFromEntry(entryIndex, tagIndex);
                });
            });
            
            // Add row delete handlers
            container.querySelectorAll('.row-delete-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const entryIndex = parseInt(btn.dataset.deleteRow);
                    attemptDeleteEntry(entryIndex);
                });
            });
            
            // Update tag usage counts in theme panel
            updateThemeUsageCounts();
        }
        
        // Pending delete info for confirmation modal
        let pendingDeleteCue = null;
        
        function attemptDeleteEntry(index) {
            const entry = state.entries[index];
            const action = entry.action;
            
            // Check if deleting this entry would break cue structure
            const isCueStart = action === '1' || action === '6';
            const isCueEnd = action === '0';
            const isMidCue = action === '2' || action === '3' || action === '4' || action === '5';
            
            if (isMidCue) {
                // Mid-cue entries can be deleted freely
                deleteEntryDirectly(index);
                return;
            }
            
            // For Cue Start/Xfade or Cue End, need to check if it breaks structure
            if (isCueStart) {
                // Find the corresponding Cue End
                const cueRange = findCueRange(index);
                if (cueRange.endIndex !== null) {
                    // There are entries in this cue - ask for confirmation
                    pendingDeleteCue = cueRange;
                    document.getElementById('deleteEntryModalBody').textContent = 
                        `This is a Cue Start. Deleting it will leave ${cueRange.endIndex - cueRange.startIndex} entry(ies) without a cue. Delete the entire cue (${cueRange.endIndex - cueRange.startIndex + 1} entries)?`;
                    document.getElementById('deleteEntryModal').classList.add('show');
                } else {
                    // Just a Cue Start with nothing after - safe to delete
                    deleteEntryDirectly(index);
                }
            } else if (isCueEnd) {
                // Find the corresponding Cue Start
                const cueRange = findCueRangeForEnd(index);
                if (cueRange.startIndex !== null) {
                    pendingDeleteCue = cueRange;
                    document.getElementById('deleteEntryModalBody').textContent = 
                        `This is a Cue End. Deleting it will leave the cue unclosed. Delete the entire cue (${cueRange.endIndex - cueRange.startIndex + 1} entries)?`;
                    document.getElementById('deleteEntryModal').classList.add('show');
                } else {
                    // Orphaned Cue End - safe to delete
                    deleteEntryDirectly(index);
                }
            }
        }
        
        function findCueRange(startIndex) {
            // Find the range from a Cue Start/Xfade to its Cue End
            let endIndex = null;
            for (let i = startIndex + 1; i < state.entries.length; i++) {
                const action = state.entries[i].action;
                if (action === '0') {
                    endIndex = i;
                    break;
                }
                if (action === '1' || action === '6') {
                    // Hit another cue start before finding end
                    endIndex = i - 1;
                    break;
                }
            }
            if (endIndex === null && startIndex < state.entries.length - 1) {
                endIndex = state.entries.length - 1;
            }
            return { startIndex, endIndex };
        }
        
        function findCueRangeForEnd(endIndex) {
            // Find the range from Cue End back to its Cue Start
            let startIndex = null;
            for (let i = endIndex - 1; i >= 0; i--) {
                const action = state.entries[i].action;
                if (action === '1' || action === '6') {
                    startIndex = i;
                    break;
                }
                if (action === '0') {
                    // Hit another cue end before finding start
                    break;
                }
            }
            return { startIndex, endIndex };
        }
        
        function deleteEntryDirectly(index) {
            state.entries.splice(index, 1);
            state.selectedEntryIndex = null;
            recalculateCueState();
            renderEntries();
            autoSave();
            showToast('Entry deleted', 'info');
        }
        
        function deleteEntireCue() {
            if (!pendingDeleteCue) return;
            
            const { startIndex, endIndex } = pendingDeleteCue;
            const count = endIndex - startIndex + 1;
            
            // Delete from end to start to preserve indices
            state.entries.splice(startIndex, count);
            state.selectedEntryIndex = null;
            recalculateCueState();
            renderEntries();
            autoSave();
            
            hideDeleteEntryModal();
            showToast(`Deleted ${count} entries`, 'info');
        }
        
        function hideDeleteEntryModal() {
            document.getElementById('deleteEntryModal').classList.remove('show');
            pendingDeleteCue = null;
        }
        
        function deleteTagFromEntry(entryIndex, tagIndex) {
            const entry = state.entries[entryIndex];
            if (entry && entry.tags && entry.tags[tagIndex] !== undefined) {
                const removedTag = entry.tags.splice(tagIndex, 1)[0];
                showToast(`Removed tag: ${removedTag}`, 'info');
                renderEntries();
                autoSave();
            }
        }
        
        function updateThemeUsageCounts() {
            const countElements = document.querySelectorAll('.theme-usage-count');
            countElements.forEach(el => {
                const entry = el.closest('.theme-entry');
                if (entry) {
                    const key = entry.dataset.key;
                    if (key && state.themes[key]) {
                        const count = getTagUsageCount(state.themes[key]);
                        el.textContent = count;
                    }
                }
            });
        }

        function makeNotesEditable(index) {
            state.isEditingNotes = true;
            const row = document.querySelector(`.entry-row[data-index="${index}"]`);
            const notesDiv = row.querySelector('.notes-cell');
            const currentNotes = state.entries[index].notes || '';
            
            notesDiv.innerHTML = `<input type="text" class="notes-input" value="${currentNotes}" placeholder="Type note and press Enter...">`;
            const input = notesDiv.querySelector('input');
            input.focus();
            input.select();
            
            const saveNotes = () => {
                const previousNote = state.entries[index].notes;
                state.entries[index].notes = input.value;
                if (input.value !== previousNote) {
                    state.actionHistory.push({ type: 'note', index, previousNote });
                }
                state.isEditingNotes = false;
                renderEntries();
                autoSave();
            };
            
            input.addEventListener('blur', saveNotes);
            input.addEventListener('keydown', (e) => {
                e.stopPropagation();
                if (e.key === 'Enter') {
                    input.blur();
                } else if (e.key === 'Escape') {
                    state.isEditingNotes = false;
                    renderEntries();
                }
            });
        }

        function makeTimecodeEditable(index) {
            state.isEditingTimecode = true;
            const row = document.querySelector(`.entry-row[data-index="${index}"]`);
            const tcDiv = row.querySelector('.timecode-display');
            const tc = framesToTimecode(state.entries[index].frames);
            const sep = state.timer.isDropFrame ? ';' : ':';
            
            tcDiv.innerHTML = `
                <div class="timecode-edit-group">
                    <input type="text" class="timecode-edit-field" value="${String(tc.hh).padStart(2, '0')}" maxlength="2" data-tc="hh">
                    <span class="timecode-edit-sep">:</span>
                    <input type="text" class="timecode-edit-field" value="${String(tc.mm).padStart(2, '0')}" maxlength="2" data-tc="mm">
                    <span class="timecode-edit-sep">:</span>
                    <input type="text" class="timecode-edit-field" value="${String(tc.ss).padStart(2, '0')}" maxlength="2" data-tc="ss">
                    <span class="timecode-edit-sep">${sep}</span>
                    <input type="text" class="timecode-edit-field" value="${String(tc.ff).padStart(2, '0')}" maxlength="2" data-tc="ff">
                </div>
            `;
            
            const inputs = tcDiv.querySelectorAll('input');
            inputs[0].focus();
            inputs[0].select();
            
            const saveTimecode = () => {
                const hh = parseInt(tcDiv.querySelector('[data-tc="hh"]').value) || 0;
                const mm = parseInt(tcDiv.querySelector('[data-tc="mm"]').value) || 0;
                const ss = parseInt(tcDiv.querySelector('[data-tc="ss"]').value) || 0;
                const ff = roundToValidFrame(parseInt(tcDiv.querySelector('[data-tc="ff"]').value) || 0);
                
                const newFrames = timecodeToFrames(hh, mm, ss, ff);
                state.entries[index].frames = newFrames;
                
                // Re-sort entries by timecode
                state.entries.sort((a, b) => a.frames - b.frames);
                state.selectedEntryIndex = state.entries.findIndex(e => e === state.entries[index]);
                
                recalculateCueState();
                state.isEditingTimecode = false;
                renderEntries();
                autoSave();
                
                // Jump timer and video to new timecode when stopped
                if (!state.timer.isPlaying) {
                    state.timer.currentFrames = newFrames;
                    updateTimerDisplay();
                    syncVideoToTimer();
                }
            };
            
            inputs.forEach((input, i) => {
                input.addEventListener('blur', (e) => {
                    // Only save if we're not focusing another tc field
                    setTimeout(() => {
                        if (!tcDiv.contains(document.activeElement)) {
                            saveTimecode();
                        }
                    }, 10);
                });
                
                input.addEventListener('keydown', (e) => {
                    e.stopPropagation();
                    if (e.key === 'Tab' && !e.shiftKey && i < inputs.length - 1) {
                        e.preventDefault();
                        inputs[i + 1].focus();
                        inputs[i + 1].select();
                    } else if (e.key === 'Tab' && e.shiftKey && i > 0) {
                        e.preventDefault();
                        inputs[i - 1].focus();
                        inputs[i - 1].select();
                    } else if (e.key === 'Enter') {
                        saveTimecode();
                    } else if (e.key === 'Escape') {
                        state.isEditingTimecode = false;
                        renderEntries();
                    }
                });
            });
        }

        function scrollToEntry(index) {
            if (index === null || index < 0) return;
            
            const container = document.getElementById('entriesContainer');
            const rows = container.querySelectorAll('.entry-row');
            
            if (rows[index]) {
                const row = rows[index];
                const containerHeight = container.clientHeight;
                const rowTop = row.offsetTop;
                const rowHeight = row.offsetHeight;
                
                // Position at 2/3 down the container
                const targetScroll = rowTop - (containerHeight * 0.66) + (rowHeight / 2);
                
                container.scrollTo({
                    top: Math.max(0, targetScroll),
                    behavior: 'smooth'
                });
            }
        }

        // ==================== THEMES ====================
        function getTagUsageCount(tagMeaning) {
            let count = 0;
            state.entries.forEach(entry => {
                if (entry.tags.includes(tagMeaning)) {
                    count++;
                }
            });
            return count;
        }
        
        function renderThemeEntries() {
            const container = document.getElementById('themeEntriesContainer');
            const usedKeys = Object.keys(state.themes).sort();
            
            let html = '';
            
            // Render existing themes (now editable) with usage counts
            usedKeys.forEach((key, idx) => {
                const meaning = state.themes[key];
                const usageCount = getTagUsageCount(meaning);
                html += `
                    <div class="theme-entry" data-key="${key}" data-index="${idx}">
                        <input type="text" class="theme-key-input" value="${key.toUpperCase()}" maxlength="1" data-original-key="${key}">
                        <input type="text" class="theme-meaning-input" value="${meaning}" data-key="${key}">
                        <span class="theme-usage-count" title="Times used">${usageCount}</span>
                        <button class="theme-delete-btn" data-key="${key}" title="Delete">√ó</button>
                    </div>
                `;
            });
            
            // Always add one blank entry if we have room
            if (usedKeys.length < 26) {
                html += `
                    <div class="theme-entry new-entry" data-index="${usedKeys.length}">
                        <input type="text" class="theme-key-input" maxlength="1" placeholder="Key">
                        <input type="text" class="theme-meaning-input" placeholder="Meaning">
                        <div style="width: 50px;"></div>
                    </div>
                `;
            }
            
            container.innerHTML = html;
            
            // Add handlers for ALL theme entries (existing and new)
            const allEntries = container.querySelectorAll('.theme-entry');
            
            allEntries.forEach((entry, entryIndex) => {
                const keyInput = entry.querySelector('.theme-key-input');
                const meaningInput = entry.querySelector('.theme-meaning-input');
                const deleteBtn = entry.querySelector('.theme-delete-btn');
                const isNewEntry = entry.classList.contains('new-entry');
                const originalKey = keyInput.dataset.originalKey;
                
                // Delete button handler
                if (deleteBtn) {
                    deleteBtn.addEventListener('click', (e) => {
                        e.preventDefault();
                        const keyToDelete = deleteBtn.dataset.key;
                        delete state.themes[keyToDelete];
                        autoSave();
                        renderThemeEntries();
                        showToast(`Removed theme "${keyToDelete.toUpperCase()}"`, 'info');
                    });
                }
                
                // Key input handler
                keyInput.addEventListener('input', (e) => {
                    const newKey = e.target.value.toLowerCase();
                    if (newKey && !/^[a-z]$/.test(newKey)) {
                        e.target.value = originalKey ? originalKey.toUpperCase() : '';
                        return;
                    }
                });
                
                keyInput.addEventListener('blur', () => {
                    const newKey = keyInput.value.toLowerCase();
                    
                    if (isNewEntry) {
                        // For new entries, just validate
                        if (newKey && state.themes[newKey]) {
                            showToast(`Key "${newKey.toUpperCase()}" is already in use`, 'error');
                            keyInput.value = '';
                        }
                    } else {
                        // For existing entries, handle key change
                        if (newKey !== originalKey) {
                            if (!newKey) {
                                // Cleared the key - restore it
                                keyInput.value = originalKey.toUpperCase();
                            } else if (state.themes[newKey]) {
                                showToast(`Key "${newKey.toUpperCase()}" is already in use`, 'error');
                                keyInput.value = originalKey.toUpperCase();
                            } else {
                                // Valid new key - migrate
                                const meaning = state.themes[originalKey];
                                delete state.themes[originalKey];
                                state.themes[newKey] = meaning;
                                autoSave();
                                renderThemeEntries();
                                showToast(`Changed key from "${originalKey.toUpperCase()}" to "${newKey.toUpperCase()}"`, 'info');
                            }
                        }
                    }
                });
                
                keyInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Tab' && !e.shiftKey) {
                        // Tab goes to meaning field (natural behavior)
                    } else if (e.key === 'Enter') {
                        e.preventDefault();
                        meaningInput.focus();
                    }
                    e.stopPropagation();
                });
                
                // Meaning input handler
                meaningInput.addEventListener('blur', () => {
                    if (isNewEntry) {
                        // Try to create new entry
                        const key = keyInput.value.toLowerCase();
                        const meaning = meaningInput.value.trim();
                        
                        if (key && meaning && /^[a-z]$/.test(key) && !state.themes[key]) {
                            state.themes[key] = meaning;
                            autoSave();
                            renderThemeEntries();
                            
                            // Focus the new blank entry's key field
                            setTimeout(() => {
                                const newBlank = document.querySelector('.new-entry .theme-key-input');
                                if (newBlank) newBlank.focus();
                            }, 50);
                        }
                    } else {
                        // Update existing meaning
                        const key = meaningInput.dataset.key;
                        const newMeaning = meaningInput.value.trim();
                        if (newMeaning) {
                            state.themes[key] = newMeaning;
                            autoSave();
                        }
                    }
                });
                
                meaningInput.addEventListener('keydown', (e) => {
                    if ((e.key === 'Tab' && !e.shiftKey) || e.key === 'Enter') {
                        // Tab and Enter both save and move to next key field
                        e.preventDefault();
                        meaningInput.blur();
                        setTimeout(() => {
                            const updatedContainer = document.getElementById('themeEntriesContainer');
                            const updatedEntries = updatedContainer.querySelectorAll('.theme-entry');
                            // Try to go to next entry, or stay at the last one (which will be the new blank)
                            let targetIndex = entryIndex + 1;
                            if (targetIndex >= updatedEntries.length) {
                                targetIndex = updatedEntries.length - 1;
                            }
                            const targetEntry = updatedEntries[targetIndex];
                            if (targetEntry) {
                                const targetKey = targetEntry.querySelector('.theme-key-input');
                                if (targetKey) targetKey.focus();
                            }
                        }, 60);
                    }
                    e.stopPropagation();
                });
            });
        }

        // ==================== CONTEXT MENU ====================
        function showContextMenu(x, y) {
            const menu = document.getElementById('contextMenu');
            menu.style.left = x + 'px';
            menu.style.top = y + 'px';
            menu.classList.add('visible');
        }

        function hideContextMenu() {
            document.getElementById('contextMenu').classList.remove('visible');
        }

        function handleContextMenuAction(action) {
            const index = state.contextMenuEntryIndex;
            if (index === null) return;
            
            switch (action) {
                case 'delete-renumber':
                    deleteEntry(index, true);
                    break;
                case 'delete-keep':
                    deleteEntry(index, false);
                    break;
                case 'insert-before':
                    insertEntry(index, 'before');
                    break;
                case 'insert-after':
                    insertEntry(index, 'after');
                    break;
                case 'set-reel-renumber':
                    setReelNumber(index, true);
                    break;
                case 'set-reel-keep':
                    setReelNumber(index, false);
                    break;
            }
            
            hideContextMenu();
        }

        function deleteEntry(index, renumber) {
            const removed = state.entries.splice(index, 1)[0];
            
            // If we're renumbering and removed a Cue Start or Xfade
            if (renumber && (removed.action === '1' || removed.action === '5')) {
                let cueNum = removed.cueNum;
                for (let i = index; i < state.entries.length; i++) {
                    if (state.entries[i].reel === removed.reel && 
                        (state.entries[i].action === '1' || state.entries[i].action === '5')) {
                        state.entries[i].cueNum = cueNum;
                        cueNum++;
                    }
                }
                state.currentCueInReel = cueNum - 1;
            }
            
            state.selectedEntryIndex = null;
            recalculateCueState();
            renderEntries();
            autoSave();
        }

        function insertEntry(index, position) {
            const newEntry = {
                frames: state.entries[index]?.frames || 0,
                action: null,
                tags: [],
                notes: '',
                reel: state.entries[index]?.reel || state.currentReel,
                cueNum: null,
                isNew: true
            };
            
            const insertIndex = position === 'before' ? index : index + 1;
            state.entries.splice(insertIndex, 0, newEntry);
            state.selectedEntryIndex = insertIndex;
            
            renderEntries();
            makeTimecodeEditable(insertIndex);
            
            showToast('Enter timecode, then press an action key (1-5 or 0)', 'info');
        }

        function setReelNumber(index, renumberSubsequent) {
            const newReel = prompt('Enter reel number:', state.entries[index].reel);
            if (newReel === null) return;
            
            const reelNum = parseInt(newReel);
            if (isNaN(reelNum) || reelNum < 1) {
                showToast('Invalid reel number', 'error');
                return;
            }
            
            if (renumberSubsequent) {
                const oldReel = state.entries[index].reel;
                const diff = reelNum - oldReel;
                for (let i = index; i < state.entries.length; i++) {
                    state.entries[i].reel += diff;
                }
            } else {
                state.entries[index].reel = reelNum;
            }
            
            renderEntries();
            autoSave();
        }

        function recalculateCueState() {
            // Ensure entries are sorted chronologically
            state.entries.sort((a, b) => a.frames - b.frames);
            
            state.lastCueStartIndex = null;
            let cueNum = 0;
            
            // Walk through entries to reassign cue numbers and find the current cue state
            for (let i = 0; i < state.entries.length; i++) {
                const entry = state.entries[i];
                const action = entry.action;
                
                if (action === '1' || action === '6') {
                    // Cue Start or Xfade - starts a new cue, gets a cue number
                    cueNum++;
                    entry.cueNum = cueNum;
                    state.lastCueStartIndex = i;
                } else if (action === '0') {
                    // Cue End - ends the cue, no cue number
                    entry.cueNum = null;
                    state.lastCueStartIndex = null;
                } else {
                    // Blank (2), Shift (3), Highlight (4), Sting (5) don't affect cue state
                    entry.cueNum = null;
                }
            }
            
            // Update the running cue counter
            state.currentCueInReel = cueNum;
        }

        // ==================== TOAST ====================
        function showToast(message, type = 'info') {
            const container = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            toast.textContent = message;
            container.appendChild(toast);
            
            setTimeout(() => {
                toast.remove();
            }, 3000);
        }

        // ==================== AUDIO ====================
        function playErrorSound() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                oscillator.frequency.value = 200;
                oscillator.type = 'square';
                gainNode.gain.value = 0.1;
                
                oscillator.start();
                oscillator.stop(audioContext.currentTime + 0.15);
            } catch (e) {
                // Audio not available
            }
        }

        // ==================== SAVE/LOAD/EXPORT ====================
        function getMetadata() {
            return {
                filmTitle: document.getElementById('filmTitle').value,
                director: document.getElementById('director').value,
                directorContact: document.getElementById('directorContact').value,
                composer: document.getElementById('composer').value,
                composerContact: document.getElementById('composerContact').value,
                version: document.getElementById('version').value,
                pictureDate: document.getElementById('pictureDate').value,
                sessionDate: document.getElementById('sessionDate').value,
                producers: document.getElementById('producers').value,
                producersContact: document.getElementById('producersContact').value,
                execProducers: document.getElementById('execProducers').value,
                execProducersContact: document.getElementById('execProducersContact').value
            };
        }

        function autoSave() {
            const data = {
                entries: state.entries,
                themes: state.themes,
                metadata: getMetadata(),
                currentReel: state.currentReel,
                currentCueInReel: state.currentCueInReel,
                fps: document.getElementById('fpsSelect').value,
                offsetFrames: state.timer.offsetFrames
            };
            
            localStorage.setItem('scoreSpotterSession', JSON.stringify(data));
        }

        function loadFromStorage() {
            const saved = localStorage.getItem('scoreSpotterSession');
            if (!saved) return;
            
            try {
                const data = JSON.parse(saved);
                
                state.entries = data.entries || [];
                state.themes = data.themes || {};
                state.currentReel = data.currentReel || 1;
                state.currentCueInReel = data.currentCueInReel || 0;
                
                if (data.metadata) {
                    document.getElementById('filmTitle').value = data.metadata.filmTitle || '';
                    document.getElementById('director').value = data.metadata.director || '';
                    document.getElementById('directorContact').value = data.metadata.directorContact || '';
                    document.getElementById('composer').value = data.metadata.composer || '';
                    document.getElementById('composerContact').value = data.metadata.composerContact || '';
                    document.getElementById('version').value = data.metadata.version || '';
                    document.getElementById('pictureDate').value = data.metadata.pictureDate || '';
                    document.getElementById('sessionDate').value = data.metadata.sessionDate || '';
                    document.getElementById('producers').value = data.metadata.producers || '';
                    document.getElementById('producersContact').value = data.metadata.producersContact || '';
                    document.getElementById('execProducers').value = data.metadata.execProducers || '';
                    document.getElementById('execProducersContact').value = data.metadata.execProducersContact || '';
                }
                
                if (data.fps) {
                    document.getElementById('fpsSelect').value = data.fps;
                    updateFps();
                }
                
                // Load offset - support both new (offsetFrames) and legacy (offset object) formats
                if (data.offsetFrames !== undefined) {
                    state.timer.offsetFrames = data.offsetFrames;
                    state.timer.currentFrames = data.offsetFrames;
                } else if (data.offset) {
                    // Legacy format - convert HH:MM:SS:FF to frames
                    const hh = parseInt(data.offset.hh) || 1;
                    const mm = parseInt(data.offset.mm) || 0;
                    const ss = parseInt(data.offset.ss) || 0;
                    const ff = parseInt(data.offset.ff) || 0;
                    state.timer.offsetFrames = timecodeToFrames(hh, mm, ss, ff);
                    state.timer.currentFrames = state.timer.offsetFrames;
                }
                
                recalculateCueState();
                renderEntries();
                renderThemeEntries();
                updateTimerDisplay();
                
            } catch (e) {
                console.error('Failed to load saved session:', e);
            }
        }

        // Generate filename in format: Score Spotting_[Film Title]_[version]_[session date]
        function generateFilename(extension) {
            const meta = getMetadata();
            const filmTitle = meta.filmTitle || 'Untitled';
            const version = meta.version ? `_${meta.version}` : '';
            const sessionDate = meta.sessionDate || new Date().toISOString().split('T')[0];
            
            // Clean filename (remove characters that might cause issues)
            const cleanTitle = filmTitle.replace(/[/\\?%*:|"<>]/g, '-');
            const cleanVersion = version.replace(/[/\\?%*:|"<>]/g, '-');
            
            return `Score Spotting_${cleanTitle}${cleanVersion}_${sessionDate}.${extension}`;
        }
        
        function downloadSession() {
            const data = {
                entries: state.entries,
                themes: state.themes,
                metadata: getMetadata(),
                currentReel: state.currentReel,
                currentCueInReel: state.currentCueInReel,
                fps: document.getElementById('fpsSelect').value,
                offsetFrames: state.timer.offsetFrames
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = generateFilename('json');
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('Session downloaded', 'info');
        }

        function loadSession(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    localStorage.setItem('scoreSpotterSession', JSON.stringify(data));
                    loadFromStorage();
                    updateVideoPanelTitle();
                    showToast('Session loaded', 'info');
                } catch (err) {
                    showToast('Failed to load session file', 'error');
                }
            };
            reader.readAsText(file);
        }

        function exportCSV() {
            const meta = getMetadata();
            const metadata = [
                `Film Title,${meta.filmTitle}`,
                `Director,${meta.director}`,
                `Version,${meta.version}`,
                `Picture Date,${meta.pictureDate}`,
                `Producers,${meta.producers}`,
                `Exec Producers,${meta.execProducers}`,
                `Composer,${meta.composer}`,
                `FPS,${document.getElementById('fpsSelect').value}`,
                ''
            ];
            
            // Build tag summary
            const tagSummary = [];
            Object.keys(state.themes).sort().forEach(key => {
                const meaning = state.themes[key];
                const count = getTagUsageCount(meaning);
                if (count > 0) {
                    tagSummary.push({ meaning, count });
                }
            });
            
            // Column order: Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag | Count
            const headers = ['Reel', 'Cue', 'Timecode', 'Action', 'Tags', 'Notes', 'Duration', '', 'Tag Summary', 'Count'];
            
            const rows = state.entries.map((entry, index) => {
                const tc = framesToTimecode(entry.frames);
                const tagEntry = tagSummary[index] || {};
                return [
                    entry.reel,
                    getCueNumber(index),
                    tc.display,
                    getActionName(entry.action),
                    entry.tags.join('; '),
                    `"${(entry.notes || '').replace(/"/g, '""')}"`,
                    calculateDuration(index),
                    '',
                    tagEntry.meaning || '',
                    tagEntry.count || ''
                ].join(',');
            });
            
            // Add remaining tag summary entries if there are more than data rows
            for (let i = state.entries.length; i < tagSummary.length; i++) {
                rows.push(['', '', '', '', '', '', '', '', tagSummary[i].meaning, tagSummary[i].count].join(','));
            }
            
            const csv = [...metadata, headers.join(','), ...rows].join('\n');
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = generateFilename('csv');
            a.click();
            URL.revokeObjectURL(url);
            
            showToast('CSV exported', 'info');
        }

        function exportXLSX() {
            const meta = getMetadata();
            
            // Create workbook
            const wb = XLSX.utils.book_new();
            
            // Define colors - muted action colors (darker/less saturated)
            const colors = {
                titleBg: 'E8E8EC',
                headerBg: '4A7CCC',
                headerText: 'FFFFFF',
                reelBlue: 'D5E5F5',
                reelGreen: 'D6F5E5',
                cueGroupA: 'F5F5F5',
                cueGroupB: 'FFFFFF',
                // Muted action colors (50% less saturated)
                cueStart: 'DCF0E0',
                cueEnd: 'F5DDD0',
                // More muted colors for non-key actions
                shift: 'ECEEF5',
                highlight: 'F5F2E8',
                sting: 'F5F0EC',
                xfade: 'EAE5F0',
                // Text colors for key actions (to apply to timecode)
                cueStartText: '2E7D32',
                cueEndText: 'C62828',
                xfadeText: '6A1B9A',
                dimText: 'AAAAAA',
                normalText: '000000',
                borderColor: 'CCCCCC'
            };
            
            // Standard border style
            const thinBorder = {
                top: { style: 'thin', color: { rgb: colors.borderColor } },
                bottom: { style: 'thin', color: { rgb: colors.borderColor } },
                left: { style: 'thin', color: { rgb: colors.borderColor } },
                right: { style: 'thin', color: { rgb: colors.borderColor } }
            };
            
            // Styles with borders - using Courier New instead of Consolas for better compatibility
            const titleStyle = { font: { bold: true, sz: 18 }, alignment: { horizontal: 'center' } };
            const headerStyle = { 
                font: { bold: true, color: { rgb: colors.headerText } }, 
                fill: { fgColor: { rgb: colors.headerBg } },
                alignment: { horizontal: 'center' },
                border: thinBorder
            };
            const metaLabelStyle = { font: { bold: true, sz: 10 } };
            const metaValueStyle = { font: { sz: 10 } };
            
            // Build header section
            const data = [];
            
            // Row 0: Title and Session Date
            data.push([
                { v: '', s: {} },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: meta.filmTitle || 'UNTITLED', s: titleStyle },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: meta.sessionDate || '', s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} },
                { v: '', s: {} }
            ]);
            
            // Rows 1-5: Metadata
            data.push([
                { v: `Director: ${meta.director || ''}`, s: metaLabelStyle },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: meta.version || '', s: { alignment: { horizontal: 'center' } } },
                { v: `Picture Date: ${meta.pictureDate || ''}`, s: metaValueStyle },
                { v: '', s: {} },
                { v: '', s: {} },
                { v: `Producers: ${meta.producers || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} },
                { v: '', s: {} }
            ]);
            data.push([
                { v: `  Contact: ${meta.directorContact || ''}`, s: metaValueStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: `  Contact: ${meta.producersContact || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} }, { v: '', s: {} }
            ]);
            data.push([
                { v: `Composer: ${meta.composer || ''}`, s: metaLabelStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: `Exec Producers: ${meta.execProducers || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} }, { v: '', s: {} }
            ]);
            data.push([
                { v: `  Contact: ${meta.composerContact || ''}`, s: metaValueStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: `  Contact: ${meta.execProducersContact || ''}`, s: { alignment: { horizontal: 'right' } } },
                { v: '', s: {} }, { v: '', s: {} }
            ]);
            data.push([
                { v: `FPS: ${document.getElementById('fpsSelect').value}`, s: metaLabelStyle },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }
            ]);
            
            // Empty row
            data.push([]);
            
            // Build tag summary data
            const tagSummary = [];
            Object.keys(state.themes).sort().forEach(key => {
                const meaning = state.themes[key];
                const count = getTagUsageCount(meaning);
                if (count > 0) {
                    tagSummary.push({ key: key.toUpperCase(), meaning, count });
                }
            });
            
            // Header row (row 7) - Column order: Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag Summary
            data.push([
                { v: 'Reel', s: headerStyle },
                { v: 'Cue', s: headerStyle },
                { v: 'Timecode', s: headerStyle },
                { v: 'Action', s: headerStyle },
                { v: 'Tags', s: headerStyle },
                { v: 'Notes', s: headerStyle },
                { v: 'Duration', s: headerStyle },
                { v: '', s: {} },
                { v: 'Tag', s: headerStyle },
                { v: 'Count', s: headerStyle }
            ]);
            
            // Add entry data with styling
            state.entries.forEach((entry, index) => {
                const tc = framesToTimecode(entry.frames);
                const cueGroup = getCueGroupIndex(index);
                const isOddGroup = cueGroup % 2 === 1;
                const reelColorClass = getReelColor(entry.reel);
                const isReelBlue = reelColorClass === 'blue';
                const isFinalDuration = entry.action === '0';  // Only Cue End is final, not Xfade
                const isKeyAction = entry.action === '1' || entry.action === '0' || entry.action === '6';
                
                // Determine row background color
                let rowBg = isOddGroup ? colors.cueGroupA : colors.cueGroupB;
                
                // Determine action-specific color (muted)
                let actionBg = rowBg;
                if (entry.action === '1') actionBg = colors.cueStart;
                else if (entry.action === '0') actionBg = colors.cueEnd;
                else if (entry.action === '3') actionBg = colors.shift;
                else if (entry.action === '4') actionBg = colors.highlight;
                else if (entry.action === '5') actionBg = colors.sting;
                else if (entry.action === '6') actionBg = colors.xfade;
                
                // Determine timecode text color for key actions
                let tcTextColor = colors.normalText;
                if (entry.action === '1') tcTextColor = colors.cueStartText;
                else if (entry.action === '0') tcTextColor = colors.cueEndText;
                else if (entry.action === '6') tcTextColor = colors.xfadeText;
                
                // Reel indicator color
                const reelBg = isReelBlue ? colors.reelBlue : colors.reelGreen;
                
                const rowStyle = { fill: { fgColor: { rgb: rowBg } }, border: thinBorder };
                const actionStyle = { fill: { fgColor: { rgb: actionBg } }, alignment: { horizontal: 'center' }, border: thinBorder };
                const reelStyle = { fill: { fgColor: { rgb: reelBg } }, alignment: { horizontal: 'center' }, font: { bold: true }, border: thinBorder };
                
                // Timecode style - colored for key actions (Cue Start, Cue End, Xfade)
                const tcStyle = isKeyAction 
                    ? { font: { name: 'Courier New', bold: true, color: { rgb: tcTextColor } }, fill: { fgColor: { rgb: actionBg } }, border: thinBorder }
                    : { font: { name: 'Courier New' }, fill: { fgColor: { rgb: rowBg } }, border: thinBorder };
                
                // Duration style - final durations are bold/dark, non-final are light gray
                const durStyle = isFinalDuration 
                    ? { font: { name: 'Courier New', bold: true, color: { rgb: colors.normalText } }, fill: { fgColor: { rgb: rowBg } }, alignment: { horizontal: 'right' }, border: thinBorder }
                    : { font: { name: 'Courier New', color: { rgb: colors.dimText } }, fill: { fgColor: { rgb: rowBg } }, alignment: { horizontal: 'right' }, border: thinBorder };
                
                // Tag summary for this row (if applicable)
                const tagSummaryEntry = tagSummary[index];
                const tagCell = tagSummaryEntry ? { v: tagSummaryEntry.meaning, s: { border: thinBorder } } : { v: '', s: {} };
                const countCell = tagSummaryEntry ? { v: tagSummaryEntry.count, s: { alignment: { horizontal: 'center' }, border: thinBorder } } : { v: '', s: {} };
                
                // Column order: Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag | Count
                data.push([
                    { v: entry.reel, s: reelStyle },
                    { v: getCueNumber(index), s: { ...rowStyle, font: { bold: true, color: { rgb: '4A7CCC' } }, border: thinBorder } },
                    { v: tc.display, s: tcStyle },
                    { v: getActionName(entry.action), s: actionStyle },
                    { v: entry.tags.join('; '), s: rowStyle },
                    { v: entry.notes || '', s: rowStyle },
                    { v: calculateDuration(index), s: durStyle },
                    { v: '', s: {} },
                    tagCell,
                    countCell
                ]);
            });
            
            // If there are more tag summary entries than data rows, add them
            for (let i = state.entries.length; i < tagSummary.length; i++) {
                const tagSummaryEntry = tagSummary[i];
                const row = [
                    { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                    { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} }, { v: '', s: {} },
                    { v: tagSummaryEntry.meaning, s: { border: thinBorder } },
                    { v: tagSummaryEntry.count, s: { alignment: { horizontal: 'center' }, border: thinBorder } }
                ];
                data.push(row);
            }
            
            // Create worksheet from styled data
            const ws = XLSX.utils.aoa_to_sheet(data.map(row => row.map ? row.map(cell => cell.v !== undefined ? cell.v : cell) : row));
            
            // Apply styles to cells
            data.forEach((row, r) => {
                if (!row.map) return;
                row.forEach((cell, c) => {
                    if (cell.s && Object.keys(cell.s).length > 0) {
                        const cellRef = XLSX.utils.encode_cell({ r, c });
                        if (ws[cellRef]) {
                            ws[cellRef].s = cell.s;
                        }
                    }
                });
            });
            
            // Set column widths - Reel | Cue | Timecode | Action | Tags | Notes | Duration | (gap) | Tag | Count
            ws['!cols'] = [
                { wch: 5 },   // Reel (narrow, just number)
                { wch: 8 },   // Cue
                { wch: 14 },  // Timecode
                { wch: 12 },  // Action
                { wch: 30 },  // Tags
                { wch: 50 },  // Notes
                { wch: 14 },  // Duration
                { wch: 3 },   // Gap
                { wch: 20 },  // Tag summary - meaning
                { wch: 8 }    // Tag summary - count
            ];
            
            // Merge cells for title
            ws['!merges'] = [
                { s: { r: 0, c: 3 }, e: { r: 0, c: 5 } }
            ];
            
            // Add worksheet to workbook
            XLSX.utils.book_append_sheet(wb, ws, 'Spotting Notes');
            
            // Generate and download
            XLSX.writeFile(wb, generateFilename('xlsx'));
            
            showToast('Excel file exported with formatting', 'info');
        }

        // ==================== NEW SESSION / CLEAR ====================
        function showNewSessionModal() {
            document.getElementById('newSessionModal').classList.add('visible');
        }

        function hideNewSessionModal() {
            document.getElementById('newSessionModal').classList.remove('visible');
        }

        function clearSession() {
            // Clear state
            state.entries = [];
            state.themes = {};
            state.currentReel = 1;
            state.currentCueInReel = 0;
            state.selectedEntryIndex = null;
            state.lastCueStartIndex = null;
            state.actionHistory = [];
            
            // Clear metadata inputs
            document.getElementById('filmTitle').value = '';
            document.getElementById('director').value = '';
            document.getElementById('directorContact').value = '';
            document.getElementById('composer').value = '';
            document.getElementById('composerContact').value = '';
            document.getElementById('version').value = '';
            document.getElementById('pictureDate').value = '';
            document.getElementById('sessionDate').value = new Date().toISOString().split('T')[0];
            document.getElementById('producers').value = '';
            document.getElementById('producersContact').value = '';
            document.getElementById('execProducers').value = '';
            document.getElementById('execProducersContact').value = '';
            
            // Reset timer settings
            document.getElementById('fpsSelect').value = '24';
            state.timer.fps = 24;
            state.timer.isDropFrame = false;
            state.timer.offsetFrames = 86400;  // Default 01:00:00:00 at 24fps
            state.timer.currentFrames = 86400;
            
            // Clear video
            clearVideo();
            
            // Clear localStorage
            localStorage.removeItem('scoreSpotterSession');
            
            // Update display
            updateTimerDisplay();
            renderEntries();
            renderThemeEntries();
            updateVideoPanelTitle();
            
            hideNewSessionModal();
            showToast('Session cleared - ready for new project', 'info');
        }
        
        function clearVideo() {
            const video = document.getElementById('videoPlayer');
            const placeholder = document.getElementById('videoPlaceholder');
            const controls = document.getElementById('videoControls');
            
            // Reset video element
            video.pause();
            video.src = '';
            video.style.display = 'none';
            
            // Show placeholder
            placeholder.style.display = 'flex';
            controls.style.display = 'none';
            
            // Reset video state
            state.video.loaded = false;
            state.video.duration = 0;
            state.video.filename = '';
            stopShuttle();
        }
        
        function clearSessionKeepInfo() {
            // Clear only entries, keep project info, themes, AND video
            state.entries = [];
            state.currentReel = 1;
            state.currentCueInReel = 0;
            state.selectedEntryIndex = null;
            state.lastCueStartIndex = null;
            state.actionHistory = [];
            
            // Update session date to today
            document.getElementById('sessionDate').value = new Date().toISOString().split('T')[0];
            
            // Reset timer to offset (but keep video loaded)
            resetTimer();
            
            // Update display
            renderEntries();
            renderThemeEntries();
            autoSave();
            
            hideNewSessionModal();
            showToast('Cues cleared - project info, tags, and video kept', 'info');
        }

        // ==================== FPS ====================
        let pendingFpsChange = null;
        
        function onFpsSelectChange() {
            const fpsValue = document.getElementById('fpsSelect').value;
            const oldFps = state.timer.fps;
            const newFps = getFpsValue(fpsValue);
            
            // If there are entries and FPS is actually changing, ask user how to handle it
            if (state.entries.length > 0 && oldFps !== newFps) {
                pendingFpsChange = { fpsValue, oldFps, newFps };
                document.getElementById('fpsChangeModal').classList.add('show');
            } else {
                // No entries or same FPS, just update
                updateFps('preserve-time');
                autoSave();
            }
        }
        
        function hideFpsModal() {
            document.getElementById('fpsChangeModal').classList.remove('show');
            // Reset the select to the previous value if cancelled
            if (pendingFpsChange) {
                const fpsString = getFpsString(state.timer.fps, state.timer.isDropFrame);
                document.getElementById('fpsSelect').value = fpsString;
            }
            pendingFpsChange = null;
        }
        
        function getFpsString(fps, isDF) {
            if (fps === 23.976) return '23.976';
            if (fps === 24) return '24';
            if (fps === 25) return '25';
            if (fps === 29.97 && !isDF) return '29.97ndf';
            if (fps === 29.97 && isDF) return '29.97df';
            if (fps === 30) return '30';
            if (fps === 48) return '48';
            if (fps === 50) return '50';
            if (fps === 59.94 && !isDF) return '59.94ndf';
            if (fps === 59.94 && isDF) return '59.94df';
            if (fps === 60) return '60';
            return '24';
        }
        
        function applyFpsChange(mode) {
            // mode: 'preserve-frames' or 'preserve-time'
            if (!pendingFpsChange) return;
            
            updateFps(mode);
            document.getElementById('fpsChangeModal').classList.remove('show');
            pendingFpsChange = null;
            autoSave();
            
            const modeText = mode === 'preserve-frames' ? 'Frame count preserved' : 'Time positions preserved';
            showToast(`Frame rate changed. ${modeText}`, 'info');
        }
        
        function updateFps(mode = 'preserve-time') {
            const fpsValue = document.getElementById('fpsSelect').value;
            const oldFps = state.timer.fps;
            const newFps = getFpsValue(fpsValue);
            const wasDropFrame = state.timer.isDropFrame;
            const isNowDropFrame = isDropFrame(fpsValue);
            
            if (mode === 'preserve-time' && oldFps !== newFps) {
                // Preserve time position: keep HH:MM:SS, adjust frames proportionally
                // Get current timecode components (HH:MM:SS:FF)
                const tc = framesToTimecode(state.timer.currentFrames);
                
                // Update fps settings first
                state.timer.fps = newFps;
                state.timer.isDropFrame = isNowDropFrame;
                
                // Calculate proportional frame (keep HH:MM:SS, scale FF)
                const oldMaxFrames = Math.floor(oldFps);
                const newMaxFrames = Math.floor(newFps);
                let newFrame = Math.round(tc.ff / oldMaxFrames * newMaxFrames);
                
                // Clamp to valid range
                if (newFrame >= newMaxFrames) newFrame = newMaxFrames - 1;
                if (newFrame < 0) newFrame = 0;
                
                // Convert back to frames with new fps (using same HH:MM:SS, new FF)
                state.timer.currentFrames = timecodeToFrames(tc.hh, tc.mm, tc.ss, newFrame);
                
                // Update offset
                const offsetTC = framesToTimecodeWithFps(state.timer.offsetFrames, oldFps, wasDropFrame);
                let newOffsetFrame = Math.round(offsetTC.ff / oldMaxFrames * newMaxFrames);
                if (newOffsetFrame >= newMaxFrames) newOffsetFrame = newMaxFrames - 1;
                if (newOffsetFrame < 0) newOffsetFrame = 0;
                
                state.timer.offsetFrames = timecodeToFrames(offsetTC.hh, offsetTC.mm, offsetTC.ss, newOffsetFrame);
                
                // Convert all entries - preserve their time positions
                state.entries.forEach(entry => {
                    const entryTC = framesToTimecodeWithFps(entry.frames, oldFps, wasDropFrame);
                    let entryNewFrame = Math.round(entryTC.ff / oldMaxFrames * newMaxFrames);
                    if (entryNewFrame >= newMaxFrames) entryNewFrame = newMaxFrames - 1;
                    if (entryNewFrame < 0) entryNewFrame = 0;
                    entry.frames = timecodeToFrames(entryTC.hh, entryTC.mm, entryTC.ss, entryNewFrame);
                });
                
            } else if (mode === 'preserve-frames' && oldFps !== newFps) {
                // Preserve frame count: entries keep same frame numbers, times will change
                // Just update the fps, don't convert entry frames
                state.timer.fps = newFps;
                state.timer.isDropFrame = isNowDropFrame;
                
                // Timer current frames stay the same
                // Entry frames stay the same
                // But the displayed timecodes will be different
                
            } else {
                // Same FPS or initial load
                state.timer.fps = newFps;
                state.timer.isDropFrame = isNowDropFrame;
            }
            
            const sep = state.timer.isDropFrame ? ';' : ':';
            document.getElementById('syncFrameSep').textContent = sep;
            document.getElementById('jumpFrameSep').textContent = sep;
            
            // Update FPS display in header
            updateFpsDisplay();
            
            updateTimerDisplay();
            renderEntries();
        }
        
        function updateFpsDisplay() {
            const fpsValue = document.getElementById('fpsSelect').value;
            document.getElementById('fpsDisplay').textContent = `FPS: ${fpsValue.replace('ndf', ' NDF').replace('df', ' DF')}`;
            
            const sep = state.timer.isDropFrame ? ';' : ':';
            document.getElementById('syncFrameSep').textContent = sep;
            document.getElementById('jumpFrameSep').textContent = sep;
        }
        
        // Helper to convert frames to timecode with specific fps (for fps switching)
        function framesToTimecodeWithFps(totalFrames, fps, dropFrame) {
            if (dropFrame && (Math.abs(fps - 29.97) < 0.01 || Math.abs(fps - 59.94) < 0.01)) {
                const dropFrames = Math.abs(fps - 29.97) < 0.01 ? 2 : 4;
                const framesPerMin = Math.round(fps * 60);
                const framesPer10Min = Math.round(fps * 60 * 10);
                
                let frameNumber = totalFrames;
                const d = Math.floor(frameNumber / framesPer10Min);
                const m = frameNumber % framesPer10Min;
                
                if (m < dropFrames) {
                    frameNumber = frameNumber + dropFrames * d;
                } else {
                    frameNumber = frameNumber + dropFrames * (d + Math.floor((m - dropFrames) / (framesPerMin - dropFrames)));
                }
                
                const maxFrames = Math.ceil(fps);
                const ff = frameNumber % maxFrames;
                const ss = Math.floor(frameNumber / maxFrames) % 60;
                const mm = Math.floor(frameNumber / (maxFrames * 60)) % 60;
                const hh = Math.floor(frameNumber / (maxFrames * 60 * 60));
                
                return { hh, mm, ss, ff };
            } else {
                const maxFrames = Math.round(fps);
                const ff = totalFrames % maxFrames;
                const totalSeconds = Math.floor(totalFrames / maxFrames);
                const ss = totalSeconds % 60;
                const mm = Math.floor(totalSeconds / 60) % 60;
                const hh = Math.floor(totalSeconds / 3600);
                
                return { hh, mm, ss, ff };
            }
        }

        // ==================== DRAGGABLE TIMER ====================
        function makeTimerDraggable() {
            const timer = document.getElementById('floatingTimer');
            let isDragging = false;
            let startX, startY, startLeft, startTop;
            
            timer.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'BUTTON') return;
                
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                
                const rect = timer.getBoundingClientRect();
                startLeft = rect.left;
                startTop = rect.top;
                
                timer.style.transform = 'none';
                timer.style.left = startLeft + 'px';
                timer.style.top = startTop + 'px';
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                
                const dx = e.clientX - startX;
                const dy = e.clientY - startY;
                
                timer.style.left = (startLeft + dx) + 'px';
                timer.style.top = (startTop + dy) + 'px';
            });
            
            document.addEventListener('mouseup', () => {
                isDragging = false;
            });
        }

        // ==================== KEYBOARD HANDLING ====================
        function handleKeydown(e) {
            // Ignore if editing notes or timecode
            if (state.isEditingNotes || state.isEditingTimecode) return;
            
            // Ignore if typing in most inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                // But allow some keys to work in the timer inputs
                if (!e.target.closest('.floating-timer') && !e.target.closest('.theme-entry')) {
                    return;
                }
                // Only allow timer/theme inputs if not the action keys
                if (!['ArrowRight', 'ArrowLeft'].includes(e.key)) {
                    return;
                }
            }
            
            // Timer controls
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                toggleTimer();
                return;
            }
            
            if (e.key === 'ArrowLeft' && e.shiftKey) {
                e.preventDefault();
                resetTimer();
                return;
            }
            
            // Shuttle controls: , and . for shuttle, < and > for single frame
            if (e.key === ',' || e.key === '<') {
                e.preventDefault();
                if (e.key === '<' || e.shiftKey) {
                    // < = single frame back
                    singleFrameStep(-1);
                } else {
                    // , = shuttle reverse
                    shuttle(-1);
                }
                return;
            }
            
            if (e.key === '.' || e.key === '>') {
                e.preventDefault();
                if (e.key === '>' || e.shiftKey) {
                    // > = single frame forward
                    singleFrameStep(1);
                } else {
                    // . = shuttle forward
                    shuttle(1);
                }
                return;
            }
            
            if (e.key === '/') {
                e.preventDefault();
                stopShuttle();  // Stop shuttle
                return;
            }
            
            // Action keys: 1=Cue Start, 2=Blank, 3=Shift, 4=Highlight, 5=Sting, 6=Xfade
            if (['1', '2', '3', '4', '5', '6'].includes(e.key)) {
                e.preventDefault();
                
                if (state.selectedEntryIndex !== null && !state.timer.isPlaying) {
                    // Change action of selected entry (only when stopped)
                    const entry = state.entries[state.selectedEntryIndex];
                    const wasStart = entry.action === '1';
                    const wasXfade = entry.action === '6';
                    const hadCueNum = wasStart || wasXfade;
                    
                    entry.action = e.key;
                    
                    // If changing to Cue Start or Xfade and didn't have a cue number
                    if ((e.key === '1' || e.key === '6') && !hadCueNum) {
                        state.currentCueInReel++;
                        entry.cueNum = state.currentCueInReel;
                    } 
                    // If changing away from Cue Start/Xfade to something else
                    else if (hadCueNum && e.key !== '1' && e.key !== '6') {
                        entry.cueNum = null;
                    }
                    
                    recalculateCueState();
                    renderEntries();
                    autoSave();
                } else {
                    // Add new entry at current timer position (works playing OR stopped)
                    addEntry(e.key);
                }
                return;
            }
            
            // Escape = Cue End (stored as '0')
            if (e.key === 'Escape') {
                e.preventDefault();
                
                if (state.selectedEntryIndex !== null && !state.timer.isPlaying) {
                    // Change selected entry to Cue End (only when stopped)
                    const entry = state.entries[state.selectedEntryIndex];
                    const hadCueNum = entry.action === '1' || entry.action === '6';
                    
                    entry.action = '0';
                    if (hadCueNum) {
                        entry.cueNum = null;
                    }
                    
                    recalculateCueState();
                    renderEntries();
                    autoSave();
                } else {
                    // Add Cue End at current timer position (works playing OR stopped)
                    addEntry('0');
                }
                return;
            }
            
            // Theme keys (A-Z)
            if (/^[a-zA-Z]$/.test(e.key) && !e.ctrlKey && !e.metaKey) {
                if (state.selectedEntryIndex !== null || state.timer.isPlaying) {
                    e.preventDefault();
                    addTagToEntry(e.key);
                }
                return;
            }
            
            // Next reel
            if (e.key === '\\') {
                e.preventDefault();
                nextReel();
                return;
            }
            
            // Delete last action
            if (e.key === 'Delete' || (e.key === 'Backspace' && !e.target.closest('input'))) {
                e.preventDefault();
                removeLastAction();
                return;
            }
            
            // Backtick to deselect
            if (e.key === '`') {
                e.preventDefault();
                state.selectedEntryIndex = null;
                renderEntries();
                return;
            }
            
            // Minus key - subtract reaction time from last entry
            if (e.key === '-') {
                e.preventDefault();
                subtractReactionTime();
                return;
            }
        }
        
        // Subtract reaction time from the most recent entry
        function subtractReactionTime() {
            if (state.entries.length === 0) {
                showToast('No entries to adjust', 'error');
                return;
            }
            
            const reactionSeconds = parseFloat(document.getElementById('reactionTime').value) || 2.0;
            const framesToSubtract = Math.round(reactionSeconds * state.timer.fps);
            
            // Get the most recent entry (or selected entry)
            const targetIndex = state.selectedEntryIndex !== null ? state.selectedEntryIndex : state.entries.length - 1;
            const entry = state.entries[targetIndex];
            
            const oldFrames = entry.frames;
            const newFrames = Math.max(0, oldFrames - framesToSubtract);
            entry.frames = newFrames;
            
            // Re-sort entries if timecode changed position
            state.entries.sort((a, b) => a.frames - b.frames);
            
            // Find the new index of the entry we just modified
            const newIndex = state.entries.findIndex(e => e === entry);
            state.selectedEntryIndex = newIndex;
            
            recalculateCueState();
            renderEntries();
            autoSave();
            
            const oldTC = framesToTimecode(oldFrames).display;
            const newTC = framesToTimecode(newFrames).display;
            showToast(`Adjusted ${oldTC} ‚Üí ${newTC} (-${reactionSeconds}s)`, 'info');
        }

        // ==================== INIT ====================
        function init() {
            // Set today's date as default session date
            const today = new Date().toISOString().split('T')[0];
            document.getElementById('sessionDate').value = today;
            
            // Load saved session first (may change FPS)
            loadFromStorage();
            
            // Initialize display (uses whatever FPS is set from load or default)
            updateTimerDisplay();
            updateFpsDisplay();
            
            // Render
            renderEntries();
            renderThemeEntries();
            updateVideoPanelTitle();
            
            // Make timer draggable
            makeTimerDraggable();
            
            // Event listeners
            document.addEventListener('keydown', handleKeydown);
            
            document.getElementById('fpsSelect').addEventListener('change', onFpsSelectChange);
            
            document.getElementById('jumpBtn').addEventListener('click', jumpToTime);
            document.getElementById('syncBtn').addEventListener('click', syncTimecode);
            
            // Sync field tab navigation
            ['syncHH', 'syncMM', 'syncSS', 'syncFF'].forEach((id, index, arr) => {
                document.getElementById(id).addEventListener('keydown', (e) => {
                    if (e.key === 'Tab' && !e.shiftKey && index < arr.length - 1) {
                        e.preventDefault();
                        document.getElementById(arr[index + 1]).focus();
                        document.getElementById(arr[index + 1]).select();
                    }
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        syncTimecode();
                    }
                });
            });
            
            // Metadata auto-save and video panel title update
            document.querySelectorAll('.header-input, .film-title-input').forEach(input => {
                input.addEventListener('change', autoSave);
                input.addEventListener('input', updateVideoPanelTitle);
            });
            
            // Also update title when film title or version specifically change
            document.getElementById('filmTitle').addEventListener('input', updateVideoPanelTitle);
            document.getElementById('version').addEventListener('input', updateVideoPanelTitle);
            
            // Save/Load/Export buttons
            document.getElementById('downloadSessionBtn').addEventListener('click', downloadSession);
            document.getElementById('loadSessionBtn').addEventListener('click', () => {
                document.getElementById('loadSessionInput').click();
            });
            document.getElementById('loadSessionInput').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    loadSession(e.target.files[0]);
                }
            });
            document.getElementById('exportCsvBtn').addEventListener('click', exportCSV);
            document.getElementById('exportXlsxBtn').addEventListener('click', exportXLSX);
            
            // New session modal
            document.getElementById('newSessionBtn').addEventListener('click', showNewSessionModal);
            document.getElementById('modalCancelBtn').addEventListener('click', hideNewSessionModal);
            document.getElementById('modalDownloadBtn').addEventListener('click', () => {
                downloadSession();
                clearSession();
            });
            document.getElementById('modalExportBtn').addEventListener('click', () => {
                exportXLSX();
                clearSession();
            });
            document.getElementById('modalClearBtn').addEventListener('click', clearSession);
            document.getElementById('modalKeepInfoBtn').addEventListener('click', clearSessionKeepInfo);
            
            // Close modal on overlay click
            document.getElementById('newSessionModal').addEventListener('click', (e) => {
                if (e.target.id === 'newSessionModal') {
                    hideNewSessionModal();
                }
            });
            
            // Delete entry modal
            document.getElementById('deleteEntryCancelBtn').addEventListener('click', hideDeleteEntryModal);
            document.getElementById('deleteEntryConfirmBtn').addEventListener('click', deleteEntireCue);
            document.getElementById('deleteEntryModal').addEventListener('click', (e) => {
                if (e.target.id === 'deleteEntryModal') {
                    hideDeleteEntryModal();
                }
            });
            
            // FPS change modal
            document.getElementById('fpsCancelBtn').addEventListener('click', hideFpsModal);
            document.getElementById('fpsPreserveFramesBtn').addEventListener('click', () => applyFpsChange('preserve-frames'));
            document.getElementById('fpsPreserveTimeBtn').addEventListener('click', () => applyFpsChange('preserve-time'));
            document.getElementById('fpsChangeModal').addEventListener('click', (e) => {
                if (e.target.id === 'fpsChangeModal') {
                    hideFpsModal();
                }
            });
            
            // Help modal
            document.getElementById('helpBtn').addEventListener('click', () => {
                document.getElementById('helpModal').classList.add('show');
            });
            document.getElementById('helpCloseBtn').addEventListener('click', () => {
                document.getElementById('helpModal').classList.remove('show');
            });
            document.getElementById('helpModal').addEventListener('click', (e) => {
                if (e.target.id === 'helpModal') {
                    document.getElementById('helpModal').classList.remove('show');
                }
            });
            
            // Context menu
            document.querySelectorAll('.context-menu-item').forEach(item => {
                item.addEventListener('click', () => {
                    handleContextMenuAction(item.dataset.action);
                });
            });
            
            document.addEventListener('click', (e) => {
                if (!e.target.closest('.context-menu')) {
                    hideContextMenu();
                }
            });
            
            // Jump field tab navigation
            ['jumpHH', 'jumpMM', 'jumpSS', 'jumpFF'].forEach((id, index, arr) => {
                document.getElementById(id).addEventListener('keydown', (e) => {
                    if (e.key === 'Tab' && !e.shiftKey && index < arr.length - 1) {
                        e.preventDefault();
                        document.getElementById(arr[index + 1]).focus();
                    }
                    if (e.key === 'Enter') {
                        jumpToTime();
                    }
                });
            });
            
            // Video panel event listeners
            document.getElementById('loadVideoBtn').addEventListener('click', () => {
                document.getElementById('videoFileInput').click();
            });
            
            document.getElementById('videoFileInput').addEventListener('change', (e) => {
                if (e.target.files[0]) {
                    loadVideo(e.target.files[0]);
                }
            });
            
            document.getElementById('collapseVideoBtn').addEventListener('click', collapseVideoPanel);
            document.getElementById('videoToggleBtn').addEventListener('click', expandVideoPanel);
            
            document.getElementById('videoScrubber').addEventListener('input', onScrubberChange);
            
            // Make video panel draggable
            const videoPanelHeader = document.getElementById('videoPanelHeader');
            const videoPanel = document.getElementById('videoPanel');
            let isDraggingVideo = false;
            let videoOffsetX, videoOffsetY;
            
            videoPanelHeader.addEventListener('mousedown', (e) => {
                // Don't drag if clicking buttons
                if (e.target.tagName === 'BUTTON' || e.target.closest('button')) return;
                
                isDraggingVideo = true;
                videoOffsetX = e.clientX - videoPanel.offsetLeft;
                videoOffsetY = e.clientY - videoPanel.offsetTop;
                videoPanel.style.transition = 'none';
                e.preventDefault();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (isDraggingVideo) {
                    const newX = e.clientX - videoOffsetX;
                    const newY = e.clientY - videoOffsetY;
                    videoPanel.style.left = newX + 'px';
                    videoPanel.style.top = newY + 'px';
                }
            });
            
            document.addEventListener('mouseup', () => {
                if (isDraggingVideo) {
                    isDraggingVideo = false;
                    videoPanel.style.transition = '';
                }
            });
            
            // Video resize handle (corner resize)
            const resizeHandle = document.getElementById('videoResizeHandle');
            let isResizing = false;
            let startWidth, startHeight, startX, startY;
            
            resizeHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                startWidth = videoPanel.offsetWidth;
                startHeight = videoPanel.offsetHeight;
                startX = e.clientX;
                startY = e.clientY;
                document.body.style.cursor = 'nwse-resize';
                e.preventDefault();
                e.stopPropagation();
            });
            
            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const newWidth = Math.max(320, startWidth + (e.clientX - startX));
                const newHeight = Math.max(250, startHeight + (e.clientY - startY));
                videoPanel.style.width = newWidth + 'px';
                // Height is auto based on video aspect ratio, but we can set a min-height
            });
            
            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                }
            });
            
            // Video player events
            const video = document.getElementById('videoPlayer');
            
            video.addEventListener('timeupdate', () => {
                if (state.timer.isPlaying) {
                    // Timer is driving, already synced in tick()
                } else if (!state.video.shuttleInterval && !state.video.isManualSeeking) {
                    // Manual scrub or external change (but not frame stepping)
                    syncTimerToVideo();
                }
            });
            
            video.addEventListener('ended', () => {
                stopTimer();
            });
        }

        // Start the app
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
